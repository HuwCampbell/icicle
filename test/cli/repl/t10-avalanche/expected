welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, core-simp is now on
ok, avalanche is now on
> > -- A rather complicated feature to convert to Avalanche
> - Avalanche:
gen$date = DATE
{
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  init [Mutable] [Buf (Sum Error Int)] acc$conv$20 = Buf 3 [] : Buf (Sum Error Int);
  load_resumable [Int] acc$c$conv$11;
  load_resumable [Buf (Sum Error Int)] acc$conv$20;
  for_facts (elem$gen$fact : (Sum Error Int),
             elem$gen$date : DateTime) in new {
    let gen$fact = pair# [(Sum Error Int)] [DateTime]
                   elem$gen$fact elem$gen$date;
    read [Mutable] [Buf (Sum Error Int)] acc$conv$20 = acc$conv$20;
    let anf$2 = fst# [(Sum Error Int)] [DateTime]
                gen$fact;
    write acc$conv$20 = Latest_push# [(Sum Error Int)]
                        acc$conv$20 anf$2;
    let anf$3 = anf$2;
    let anf$4 = Sum_fold# [Error] [Int] [(Sum Error Bool)]
                (
                \reify$0$conv$4 : Error. 
                left# [Error] [Bool]
                reify$0$conv$4) (
                \reify$1$conv$5 : Int. 
                right# [Error] [Bool] (gt# [Int]
                                       reify$1$conv$5 (10 : Int)))
                anf$3;
    if (Sum_fold# [Error] [Bool] [Bool]
        (
        \reify$2$conv$7 : Error. 
        True : Bool) (
        \reify$3$conv$8 : Bool. 
        reify$3$conv$8) anf$4) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
  }
  save_resumable [Int] acc$c$conv$11;
  save_resumable [Buf (Sum Error Int)] acc$conv$20;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  read [Mutable] [Buf (Sum Error Int)] conv$20 = acc$conv$20;
  let conv$12 = right# [Error] [Int]
                c$conv$11;
  let conv$25 = Sum_fold# [Error] [Int] [(Sum Error (Int, Array (Sum Error Int)))]
                (
                \reify$4$conv$13 : Error.  
                let conv$14 = left# [Error] [(Int, Array (Sum Error Int))]
                              reify$4$conv$13
                 in conv$14) (
                \reify$5$conv$15 : Int.  
                let conv$21 = Latest_read# [(Sum Error Int)]
                              conv$20
                 in 
                let conv$22 = pair# [Int] [Array (Sum Error Int)]
                              reify$5$conv$15 conv$21
                 in 
                let conv$23 = right# [Error] [(Int, Array (Sum Error Int))]
                              conv$22
                 in conv$23) conv$12;
  output repl conv$25;
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > -- Something involves the abstract buffer type
> - Avalanche:
gen$date = DATE
{
  init [Mutable] [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2 = Map [] : Map DateTime (Buf ((Sum Error Int), DateTime));
  load_resumable [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2;
  for_facts (elem$gen$fact : (Sum Error Int),
             elem$gen$date : DateTime) in new {
    let gen$fact = pair# [(Sum Error Int)] [DateTime]
                   elem$gen$fact elem$gen$date;
    read [Mutable] [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2 = acc$conv$2;
    let anf$0 = Latest_push# [((Sum Error Int), DateTime)]
                (Buf 2 [] : Buf ((Sum Error Int), DateTime))
                gen$fact;
    let anf$1 = snd# [(Sum Error Int)] [DateTime]
                gen$fact;
    write acc$conv$2 = Map_insertOrUpdate# [DateTime] [Buf ((Sum Error Int), DateTime)]
                       (
                       \conv$7 : Buf ((Sum Error Int), DateTime). 
                       Latest_push# [((Sum Error Int), DateTime)]
                       conv$7 gen$fact) anf$0 anf$1
                       acc$conv$2;
  }
  save_resumable [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2;
  read [Mutable] [Map DateTime (Buf ((Sum Error Int), DateTime))] conv$2 = acc$conv$2;
  let conv$3 = Map_fold# [DateTime] [Buf ((Sum Error Int), DateTime)] [(Sum Error (Map DateTime Int))]
               (
               \conv$4 : (Sum Error (Map DateTime Int)). 
               
               \conv$26 : DateTime.  
               \conv$5 : Buf ((Sum Error Int), DateTime). 
               Sum_fold# [Error] [Map DateTime Int] [(Sum Error (Map DateTime Int))]
               (
               \conv$31 : Error. 
               left# [Error] [Map DateTime Int]
               conv$31) (
               \conv$30 : Map DateTime Int. 
               Sum_fold# [Error] [Int] [(Sum Error (Map DateTime Int))]
               (
               \conv$31 : Error. 
               left# [Error] [Map DateTime Int]
               conv$31) (
               \conv$28 : Int. 
               right# [Error] [Map DateTime Int]
               (Map_insertOrUpdate# [DateTime] [Int]
                (
                \conv$29 : Int.  conv$29)
                conv$28 conv$26 conv$30)) (
               let conv$11 = 
                             let conv$6 = Latest_read# [((Sum Error Int), DateTime)]
                                          conv$5
                              in Array_fold# [((Sum Error Int), DateTime)] [((Sum Error Int), ((Sum Error Int), Unit))]
                                 (
                                 \conv$10 : ((Sum Error Int), ((Sum Error Int), Unit)). 
                                 
                                 \conv$9 : ((Sum Error Int), DateTime). 
                                 
                                 let v$inline$0$conv$13 = fst# [(Sum Error Int)] [DateTime]
                                                          conv$9
                                  in pair# [(Sum Error Int)] [((Sum Error Int), Unit)]
                                     v$inline$0$conv$13 (
                                     let conv$24 = snd# [(Sum Error Int)] [((Sum Error Int), Unit)]
                                                   conv$10
                                      in 
                                     let s$conv$22 = 
                                                     let s$conv$14 = fst# [(Sum Error Int)] [Unit]
                                                                     conv$24
                                                      in Sum_fold# [Error] [Int] [(Sum Error Int)]
                                                         (
                                                         \reify$0$conv$15 : Error. 
                                                         left# [Error] [Int]
                                                         reify$0$conv$15) (
                                                         \reify$1$conv$16 : Int. 
                                                         Sum_fold# [Error] [Int] [(Sum Error Int)]
                                                         (
                                                         \reify$2$conv$17 : Error. 
                                                         left# [Error] [Int]
                                                         reify$2$conv$17) (
                                                         \reify$3$conv$18 : Int. 
                                                         right# [Error] [Int]
                                                         (add# [Int]
                                                          reify$1$conv$16
                                                          reify$3$conv$18))
                                                         s$conv$14)
                                                         v$inline$0$conv$13
                                      in pair# [(Sum Error Int)] [Unit]
                                         s$conv$22 (() : Unit)))
                                 ((Left ExceptTombstone, (Right 0, ())) : ((Sum Error Int), ((Sum Error Int), Unit)))
                                 conv$6
                in 
               let conv$24 = snd# [(Sum Error Int)] [((Sum Error Int), Unit)]
                             conv$11
                in 
               let s$conv$22 = 
                               let conv$21 = fst# [(Sum Error Int)] [Unit]
                                             conv$24
                                in conv$21
                in s$conv$22)) conv$4)
               (Right Map [] : (Sum Error (Map DateTime Int)))
               conv$2;
  output repl conv$3;
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > 