welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, core-simp is now on
ok, avalanche is now on
> > -- A rather complicated feature to convert to Avalanche
> - Avalanche:
gen$date = DATE
{
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  init [Mutable] [(Sum Error (Buf Int))] acc$conv$22 = Right Buf 3 [] : (Sum Error (Buf Int));
  load_resumable [Int] acc$c$conv$11;
  load_resumable [(Sum Error (Buf Int))] acc$conv$22;
  for_facts (gen$fact : ((Sum Error Int), DateTime)) in new {
    read [Mutable] [(Sum Error (Buf Int))] acc$conv$22 = acc$conv$22;
    write acc$conv$22 = Sum_fold# [Error] [Buf Int] [(Sum Error (Buf Int))]
                        (
                        \conv$21 : Error. 
                        left# [Error] [Buf Int] conv$21)
                        (
                        \conv$19 : Buf Int. 
                        Sum_fold# [Error] [Int] [(Sum Error (Buf Int))]
                        (
                        \conv$21 : Error. 
                        left# [Error] [Buf Int] conv$21)
                        (
                        \conv$20 : Int. 
                        right# [Error] [Buf Int]
                        (Latest_push# [Int] conv$19
                         conv$20))
                        (fst# [(Sum Error Int)] [DateTime]
                         gen$fact)) acc$conv$22;
    let anf$2 = fst# [(Sum Error Int)] [DateTime]
                gen$fact;
    let anf$3 = Sum_fold# [Error] [Int] [(Sum Error Bool)]
                (
                \reify$0$conv$4 : Error. 
                left# [Error] [Bool]
                reify$0$conv$4) (
                \reify$1$conv$5 : Int. 
                right# [Error] [Bool] (gt# [Int]
                                       reify$1$conv$5 (10 : Int)))
                anf$2;
    if (Sum_fold# [Error] [Bool] [Bool]
        (
        \reify$2$conv$7 : Error. 
        True : Bool) (
        \reify$3$conv$8 : Bool. 
        reify$3$conv$8) anf$3) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
  }
  save_resumable [Int] acc$c$conv$11;
  save_resumable [(Sum Error (Buf Int))] acc$conv$22;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  read [Mutable] [(Sum Error (Buf Int))] conv$22 = acc$conv$22;
  let conv$12 = right# [Error] [Int]
                c$conv$11;
  let conv$32 = Sum_fold# [Error] [Int] [(Sum Error (Int, Array Int))]
                (
                \reify$4$conv$13 : Error.  
                let conv$14 = left# [Error] [(Int, Array Int)]
                              reify$4$conv$13
                 in conv$14) (
                \reify$5$conv$15 : Int.  
                let conv$23 = Sum_fold# [Error] [Buf Int] [(Sum Error (Array Int))]
                              (
                              \conv$21 : Error. 
                              left# [Error] [Array Int]
                              conv$21) (
                              \conv$20 : Buf Int. 
                              right# [Error] [Array Int]
                              (Latest_read# [Int] conv$20))
                              conv$22
                 in 
                let conv$30 = Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
                              (
                              \reify$6$conv$24 : Error.  
                              let conv$25 = left# [Error] [(Int, Array Int)]
                                            reify$6$conv$24
                               in conv$25) (
                              \reify$7$conv$26 : Array Int.  
                              let conv$27 = pair# [Int] [Array Int]
                                            reify$5$conv$15 reify$7$conv$26
                               in 
                              let conv$28 = right# [Error] [(Int, Array Int)]
                                            conv$27
                               in conv$28) conv$23
                 in conv$30) conv$12;
  output repl conv$32;
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > -- Something involves the abstract buffer type
> - Avalanche:
gen$date = DATE
{
  init [Mutable] [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2 = Map [] : Map DateTime (Buf ((Sum Error Int), DateTime));
  load_resumable [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2;
  for_facts (gen$fact : ((Sum Error Int), DateTime)) in new {
    read [Mutable] [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2 = acc$conv$2;
    let anf$0 = Latest_push# [((Sum Error Int), DateTime)]
                (Buf 2 [] : Buf ((Sum Error Int), DateTime))
                gen$fact;
    let anf$1 = snd# [(Sum Error Int)] [DateTime]
                gen$fact;
    write acc$conv$2 = Map_insertOrUpdate# [DateTime] [Buf ((Sum Error Int), DateTime)]
                       (
                       \conv$7 : Buf ((Sum Error Int), DateTime). 
                       Latest_push# [((Sum Error Int), DateTime)]
                       conv$7 gen$fact) anf$0 anf$1
                       acc$conv$2;
  }
  save_resumable [Map DateTime (Buf ((Sum Error Int), DateTime))] acc$conv$2;
  read [Mutable] [Map DateTime (Buf ((Sum Error Int), DateTime))] conv$2 = acc$conv$2;
  let conv$3 = Map_fold# [DateTime] [Buf ((Sum Error Int), DateTime)] [(Sum Error (Map DateTime Int))]
               (
               \conv$4 : (Sum Error (Map DateTime Int)). 
               
               \conv$26 : DateTime.  
               \conv$5 : Buf ((Sum Error Int), DateTime). 
               Sum_fold# [Error] [Map DateTime Int] [(Sum Error (Map DateTime Int))]
               (
               \conv$31 : Error. 
               left# [Error] [Map DateTime Int]
               conv$31) (
               \conv$30 : Map DateTime Int. 
               Sum_fold# [Error] [Int] [(Sum Error (Map DateTime Int))]
               (
               \conv$31 : Error. 
               left# [Error] [Map DateTime Int]
               conv$31) (
               \conv$28 : Int. 
               right# [Error] [Map DateTime Int]
               (Map_insertOrUpdate# [DateTime] [Int]
                (
                \conv$29 : Int.  conv$29)
                conv$28 conv$26 conv$30)) (
               let conv$11 = 
                             let conv$6 = Latest_read# [((Sum Error Int), DateTime)]
                                          conv$5
                              in Array_fold# [((Sum Error Int), DateTime)] [((Sum Error Int), ((Sum Error Int), Unit))]
                                 (
                                 \conv$10 : ((Sum Error Int), ((Sum Error Int), Unit)). 
                                 
                                 \conv$9 : ((Sum Error Int), DateTime). 
                                 
                                 let v$inline$0$conv$13 = fst# [(Sum Error Int)] [DateTime]
                                                          conv$9
                                  in pair# [(Sum Error Int)] [((Sum Error Int), Unit)]
                                     v$inline$0$conv$13 (
                                     let conv$24 = snd# [(Sum Error Int)] [((Sum Error Int), Unit)]
                                                   conv$10
                                      in 
                                     let s$conv$22 = 
                                                     let s$conv$14 = fst# [(Sum Error Int)] [Unit]
                                                                     conv$24
                                                      in Sum_fold# [Error] [Int] [(Sum Error Int)]
                                                         (
                                                         \reify$0$conv$15 : Error. 
                                                         left# [Error] [Int]
                                                         reify$0$conv$15) (
                                                         \reify$1$conv$16 : Int. 
                                                         Sum_fold# [Error] [Int] [(Sum Error Int)]
                                                         (
                                                         \reify$2$conv$17 : Error. 
                                                         left# [Error] [Int]
                                                         reify$2$conv$17) (
                                                         \reify$3$conv$18 : Int. 
                                                         right# [Error] [Int]
                                                         (add# [Int]
                                                          reify$1$conv$16
                                                          reify$3$conv$18))
                                                         s$conv$14)
                                                         v$inline$0$conv$13
                                      in pair# [(Sum Error Int)] [Unit]
                                         s$conv$22 (() : Unit)))
                                 ((Left ExceptTombstone, (Right 0, ())) : ((Sum Error Int), ((Sum Error Int), Unit)))
                                 conv$6
                in 
               let conv$24 = snd# [(Sum Error Int)] [((Sum Error Int), Unit)]
                             conv$11
                in 
               let s$conv$22 = 
                               let conv$21 = fst# [(Sum Error Int)] [Unit]
                                             conv$24
                                in conv$21
                in s$conv$22)) conv$4)
               (Right Map [] : (Sum Error (Map DateTime Int)))
               conv$2;
  output repl conv$3;
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > 