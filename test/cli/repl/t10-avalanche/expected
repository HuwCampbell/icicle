welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, type is now on
ok, core is now on
ok, core-simp is now on
ok, core-type is now on
ok, avalanche is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Type:
Aggregate Possibly (Int, (Array Int))

- Core:
Program (source : Stream (Sum Error Int))
Precomputations:

Stream transformers:
conv$0 =
    source
conv$2 =
    sfilter [((Sum Error Int), DateTime)]
    (
    \conv$3 : ((Sum Error Int), DateTime). 
    
    let simp$2 = fst# [(Sum Error Int)] [DateTime]
                 conv$3
     in 
    let simp$3 = Sum_fold# [Error] [Int] [(Sum Error Bool)]
                 (
                 \reify$0$conv$4 : Error. 
                 left# [Error] [Bool]
                 reify$0$conv$4) (
                 \reify$1$conv$5 : Int. 
                 right# [Error] [Bool] (gt# [Int]
                                        reify$1$conv$5 (10 : Int)))
                 simp$2
     in Sum_fold# [Error] [Bool] [Bool]
        (
        \reify$2$conv$7 : Error. 
        True : Bool) (
        \reify$3$conv$8 : Bool. 
        reify$3$conv$8) simp$3) conv$0
conv$17 =
    smap    [((Sum Error Int), DateTime)] [(Sum Error Int)]
    (
    \conv$18 : ((Sum Error Int), DateTime). 
    fst# [(Sum Error Int)] [DateTime]
    conv$18) conv$0
Reductions:
c$conv$11 =
    rfold  
    [((Sum Error Int), DateTime)]
    [Int] (
    \c$conv$11 : Int.  
    \conv$10 : ((Sum Error Int), DateTime). 
    add# [Int] c$conv$11 (1 : Int))
    (0 : Int) conv$2
conv$16 =
    rlatest [(Sum Error Int)]
    (3 : Int) conv$17
Postcomputations with date as now$conv$1:
conv$12 =
    right# [Error] [Int]
    c$conv$11
conv$27 =
    Sum_fold# [Error] [Int] [(Sum Error (Int, Array Int))]
    (
    \reify$4$conv$13 : Error.  
    let conv$14 = left# [Error] [(Int, Array Int)]
                  reify$4$conv$13
     in conv$14) (
    \reify$5$conv$15 : Int.  
    let conv$25 = Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
                  (
                  \reify$6$conv$19 : Error.  
                  let conv$20 = left# [Error] [(Int, Array Int)]
                                reify$6$conv$19
                   in conv$20) (
                  \reify$7$conv$21 : Array Int.  
                  let conv$22 = pair# [Int] [Array Int]
                                reify$5$conv$15 reify$7$conv$21
                   in 
                  let conv$23 = right# [Error] [(Int, Array Int)]
                                conv$22
                   in conv$23) conv$16
     in conv$25) conv$12
Returning:
repl =
    conv$27


- Core type error:
Post error: 
    Application error:
      Fun: Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
           (
           \reify$6$conv$19 : Error.  
           let conv$20 = left# [Error] [(Int, Array Int)]
                         reify$6$conv$19
            in conv$20) (
           \reify$7$conv$21 : Array Int.  
           let conv$22 = pair# [Int] [Array Int]
                         reify$5$conv$15 reify$7$conv$21
            in 
           let conv$23 = right# [Error] [(Int, Array Int)]
                         conv$22
            in conv$23)
      With type: (Sum Error (Array Int)) -> (Sum Error (Int, Array Int))
      Arg: conv$16
      With type: Array (Sum Error Int)
      

- Avalanche:
gen$date = DATE
{
  init [Latest] [(Sum Error Int)] acc$conv$16 = 3 : Int;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in history {
    let gen$fact = pair# [(Sum Error Int)] [DateTime]
                   elem$gen$fact elem$gen$date;
    let elem$conv$17 = fst# [(Sum Error Int)] [DateTime]
                       gen$fact;
    push acc$conv$16(elem$conv$17);
  }
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  load_resumable [Int] acc$c$conv$11;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in new {
    let gen$fact = pair# [(Sum Error Int)] [DateTime]
                   elem$gen$fact elem$gen$date;
    let anf$2 = fst# [(Sum Error Int)] [DateTime]
                gen$fact;
    let anf$3 = Sum_fold# [Error] [Int] [(Sum Error Bool)]
                (
                \reify$0$conv$4 : Error. 
                left# [Error] [Bool]
                reify$0$conv$4) (
                \reify$1$conv$5 : Int. 
                right# [Error] [Bool] (gt# [Int]
                                       reify$1$conv$5 (10 : Int)))
                anf$2;
    if (Sum_fold# [Error] [Bool] [Bool]
        (
        \reify$2$conv$7 : Error. 
        True : Bool) (
        \reify$3$conv$8 : Bool. 
        reify$3$conv$8) anf$3) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
    let elem$conv$17 = anf$2;
    push acc$conv$16(elem$conv$17);
  }
  save_resumable [Int] acc$c$conv$11;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  read [Latest] [(Sum Error Int)] conv$16 = acc$conv$16;
  let conv$12 = right# [Error] [Int]
                c$conv$11;
  let conv$27 = Sum_fold# [Error] [Int] [(Sum Error (Int, Array Int))]
                (
                \reify$4$conv$13 : Error.  
                let conv$14 = left# [Error] [(Int, Array Int)]
                              reify$4$conv$13
                 in conv$14) (
                \reify$5$conv$15 : Int.  
                let conv$25 = Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
                              (
                              \reify$6$conv$19 : Error.  
                              let conv$20 = left# [Error] [(Int, Array Int)]
                                            reify$6$conv$19
                               in conv$20) (
                              \reify$7$conv$21 : Array Int.  
                              let conv$22 = pair# [Int] [Array Int]
                                            reify$5$conv$15 reify$7$conv$21
                               in 
                              let conv$23 = right# [Error] [(Int, Array Int)]
                                            conv$22
                               in conv$23) conv$16
                 in conv$25) conv$12;
  output repl conv$27;
}

- Flattened:
gen$date = DATE
{
  init [Latest] [(Sum Error Int)] acc$conv$16 = 3 : Int;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in history {
    push acc$conv$16(elem$gen$fact);
  } 
  
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  load_resumable [Int] acc$c$conv$11;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in new {
    init [Mutable] [(Sum Error Bool)] flat$0 = Left ExceptTombstone : (Sum Error Bool);
    if (Sum_isLeft# [Error] [Int]
        elem$gen$fact) {
      let flat$4 = unsafe_Sum_left# [Error] [Int]
                   elem$gen$fact;
      write flat$0 = left# [Error] [Bool]
                     flat$4;
    } else {
      let flat$5 = unsafe_Sum_right# [Error] [Int]
                   elem$gen$fact;
      let simp$1 = gt# [Int] flat$5
                   (10 : Int);
      write flat$0 = right# [Error] [Bool]
                     simp$1;
    }
    read [Mutable] [(Sum Error Bool)] flat$0 = flat$0;
    init [Mutable] [Bool] flat$1 = False : Bool;
    if (Sum_isLeft# [Error] [Bool]
        flat$0) {
      write flat$1 = True : Bool;
    } 
     else {
      let flat$3 = unsafe_Sum_right# [Error] [Bool]
                   flat$0;
      write flat$1 = flat$3;
    }
    read [Mutable] [Bool] flat$1 = flat$1;
    if (flat$1) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
    push acc$conv$16(elem$gen$fact);
  }
  save_resumable [Int] acc$c$conv$11;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  read [Latest] [(Sum Error Int)] conv$16 = acc$conv$16;
  let conv$12 = right# [Error] [Int]
                c$conv$11;
  init [Mutable] [(Sum Error (Int, Array Int))] flat$6 = Left ExceptTombstone : (Sum Error (Int, Array Int));
  if (Sum_isLeft# [Error] [Int]
      conv$12) {
    let flat$7 = unsafe_Sum_left# [Error] [Int]
                 conv$12;
    let conv$14 = left# [Error] [(Int, Array Int)]
                  flat$7;
    write flat$6 = conv$14;
  } else {
    let flat$8 = unsafe_Sum_right# [Error] [Int]
                 conv$12;
    init [Mutable] [(Sum Error (Int, Array Int))] flat$9 = Left ExceptTombstone : (Sum Error (Int, Array Int));
    if (Sum_isLeft# [Error] [Array Int]
        conv$16) {
      let flat$10 = unsafe_Sum_left# [Error] [Array Int]
                    conv$16;
      let conv$20 = left# [Error] [(Int, Array Int)]
                    flat$10;
      write flat$9 = conv$20;
    } else {
      let flat$11 = unsafe_Sum_right# [Error] [Array Int]
                    conv$16;
      let conv$22 = pair# [Int] [Array Int]
                    flat$8 flat$11;
      let conv$23 = right# [Error] [(Int, Array Int)]
                    conv$22;
      write flat$9 = conv$23;
    }
    read [Mutable] [(Sum Error (Int, Array Int))] flat$9 = flat$9;
    write flat$6 = flat$9;
  }
  read [Mutable] [(Sum Error (Int, Array Int))] flat$6 = flat$6;
  output repl flat$6;
}

- Avalanche type error:
Program error:
  ProgramErrorExp (ExpErrorApp (XPrim () (PrimProject (PrimProjectSumIsLeft ErrorT (ArrayT IntT)))) (XVar () (NameMod "conv" (Name "16"))) (FunT [FunT [] (SumT ErrorT (ArrayT IntT))] BoolT) (FunT [] (ArrayT (SumT ErrorT IntT))))

- Core error:
Runtime error:
  Postcomputation error:
    Bad arguments to primitive: 
      Primitive: Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
      Arguments: [closure# [(c$conv$11
                            ,5)
                           ,(conv$12,Right 5)
                           ,(conv$16
                            ,[Right 300
                             ,Right 400
                             ,Right 500])
                           ,(now$conv$1,1970-01-01)
                           ,(reify$5$conv$15
                            ,5)] \reify$6$conv$19. 
                 let conv$20 = left# [Error] [(Int, Array Int)]
                               reify$6$conv$19
                  in conv$20
                 ,closure# [(c$conv$11,5)
                           ,(conv$12,Right 5)
                           ,(conv$16
                            ,[Right 300
                             ,Right 400
                             ,Right 500])
                           ,(now$conv$1,1970-01-01)
                           ,(reify$5$conv$15
                            ,5)] \reify$7$conv$21. 
                 let conv$22 = pair# [Int] [Array Int]
                               reify$5$conv$15 reify$7$conv$21
                  in 
                 let conv$23 = right# [Error] [(Int, Array Int)]
                               conv$22
                  in conv$23
                 ,[Right 300
                  ,Right 400
                  ,Right 500]]

> > 