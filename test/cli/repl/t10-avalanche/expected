welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, type is now on
ok, core is now on
ok, core-simp is now on
ok, core-type is now on
ok, avalanche is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Type:
Aggregate Possibly (Int, (Array Int))

- Core:
Program (source : Stream (Sum Error Int))
Precomputations:

Stream transformers:
conv$0 =
    source
conv$2 =
    sfilter [((Sum Error Int), DateTime)]
    (
    \conv$3 : ((Sum Error Int), DateTime). 
    
    let simp$2 = fst# [(Sum Error Int)] [DateTime]
                 conv$3
     in 
    let simp$3 = Sum_fold# [Error] [Int] [(Sum Error Bool)]
                 (
                 \reify$0$conv$4 : Error. 
                 left# [Error] [Bool]
                 reify$0$conv$4) (
                 \reify$1$conv$5 : Int. 
                 right# [Error] [Bool] (gt# [Int]
                                        reify$1$conv$5 (10 : Int)))
                 simp$2
     in Sum_fold# [Error] [Bool] [Bool]
        (
        \reify$2$conv$7 : Error. 
        True : Bool) (
        \reify$3$conv$8 : Bool. 
        reify$3$conv$8) simp$3) conv$0
conv$17 =
    smap    [((Sum Error Int), DateTime)] [(Sum Error Int)]
    (
    \conv$18 : ((Sum Error Int), DateTime). 
    fst# [(Sum Error Int)] [DateTime]
    conv$18) conv$0
Reductions:
c$conv$11 =
    rfold  
    [((Sum Error Int), DateTime)]
    [Int] (
    \c$conv$11 : Int.  
    \conv$10 : ((Sum Error Int), DateTime). 
    add# [Int] c$conv$11 (1 : Int))
    (0 : Int) conv$2
<<<<<<< HEAD
conv$16 =
    rlatest [(Sum Error Int)]
    (3 : Int) conv$17
Postcomputations with date as now$conv$1:
conv$12 =
    right# [Error] [Int]
    c$conv$11
conv$27 =
    Sum_fold# [Error] [Int] [(Sum Error (Int, Array Int))]
    (
    \reify$4$conv$13 : Error.  
    let conv$14 = left# [Error] [(Int, Array Int)]
                  reify$4$conv$13
     in conv$14) (
    \reify$5$conv$15 : Int.  
    let conv$25 = Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
                  (
                  \reify$6$conv$19 : Error.  
                  let conv$20 = left# [Error] [(Int, Array Int)]
                                reify$6$conv$19
                   in conv$20) (
                  \reify$7$conv$21 : Array Int.  
                  let conv$22 = pair# [Int] [Array Int]
                                reify$5$conv$15 reify$7$conv$21
                   in 
                  let conv$23 = right# [Error] [(Int, Array Int)]
                                conv$22
                   in conv$23) conv$16
     in conv$25) conv$12
Returning:
repl =
    conv$27
=======
conv$9 =
    rfold   [Int] [Buf Int] (
    \conv$10 : Buf Int.  
    \conv$11 : Int. 
    Latest_push# [Int] conv$10
    conv$11)
    ([ExceptScalarVariableNotAvailable
     ,ExceptScalarVariableNotAvailable
     ,ExceptScalarVariableNotAvailable] : Buf Int)
    conv$7
Postcomputations with date as now$conv$1:
conv$6 =
    Latest_read# [Int] conv$9
conv$12 =
    pair# [Int] [Array Int]
    c$conv$5 conv$6
Returning:
repl =
    conv$12
>>>>>>> 1c6d00cdeacf74e593a515edefbae9ff2bbba592


- Core type error:
Post error: 
    Application error:
      Fun: Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
           (
           \reify$6$conv$19 : Error.  
           let conv$20 = left# [Error] [(Int, Array Int)]
                         reify$6$conv$19
            in conv$20) (
           \reify$7$conv$21 : Array Int.  
           let conv$22 = pair# [Int] [Array Int]
                         reify$5$conv$15 reify$7$conv$21
            in 
           let conv$23 = right# [Error] [(Int, Array Int)]
                         conv$22
            in conv$23)
      With type: (Sum Error (Array Int)) -> (Sum Error (Int, Array Int))
      Arg: conv$16
      With type: Array (Sum Error Int)
      

- Avalanche:
gen$date = DATE
{
<<<<<<< HEAD
  init [Latest] [(Sum Error Int)] acc$conv$16 = 3 : Int;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in history {
    let gen$fact = pair# [(Sum Error Int)] [DateTime]
                   elem$gen$fact elem$gen$date;
    let elem$conv$17 = fst# [(Sum Error Int)] [DateTime]
                       gen$fact;
    push acc$conv$16(elem$conv$17);
  }
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  load_resumable [Int] acc$c$conv$11;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in new {
    let gen$fact = pair# [(Sum Error Int)] [DateTime]
=======
  init [Mutable] [Int] acc$c$conv$5 = 0 : Int;
  init [Mutable] [Buf Int] acc$conv$9 = [ExceptScalarVariableNotAvailable
                                        ,ExceptScalarVariableNotAvailable
                                        ,ExceptScalarVariableNotAvailable] : Buf Int;
  load_resumable [Int] acc$c$conv$5;
  load_resumable [Buf Int] acc$conv$9;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    let gen$fact = pair# [Int] [DateTime]
>>>>>>> 1c6d00cdeacf74e593a515edefbae9ff2bbba592
                   elem$gen$fact elem$gen$date;
    let anf$2 = fst# [(Sum Error Int)] [DateTime]
                gen$fact;
    let anf$3 = Sum_fold# [Error] [Int] [(Sum Error Bool)]
                (
                \reify$0$conv$4 : Error. 
                left# [Error] [Bool]
                reify$0$conv$4) (
                \reify$1$conv$5 : Int. 
                right# [Error] [Bool] (gt# [Int]
                                       reify$1$conv$5 (10 : Int)))
                anf$2;
    if (Sum_fold# [Error] [Bool] [Bool]
        (
        \reify$2$conv$7 : Error. 
        True : Bool) (
        \reify$3$conv$8 : Bool. 
        reify$3$conv$8) anf$3) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
<<<<<<< HEAD
    let elem$conv$17 = anf$2;
    push acc$conv$16(elem$conv$17);
  }
  save_resumable [Int] acc$c$conv$11;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  read [Latest] [(Sum Error Int)] conv$16 = acc$conv$16;
  let conv$12 = right# [Error] [Int]
                c$conv$11;
  let conv$27 = Sum_fold# [Error] [Int] [(Sum Error (Int, Array Int))]
                (
                \reify$4$conv$13 : Error.  
                let conv$14 = left# [Error] [(Int, Array Int)]
                              reify$4$conv$13
                 in conv$14) (
                \reify$5$conv$15 : Int.  
                let conv$25 = Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
                              (
                              \reify$6$conv$19 : Error.  
                              let conv$20 = left# [Error] [(Int, Array Int)]
                                            reify$6$conv$19
                               in conv$20) (
                              \reify$7$conv$21 : Array Int.  
                              let conv$22 = pair# [Int] [Array Int]
                                            reify$5$conv$15 reify$7$conv$21
                               in 
                              let conv$23 = right# [Error] [(Int, Array Int)]
                                            conv$22
                               in conv$23) conv$16
                 in conv$25) conv$12;
  output repl conv$27;
=======
    let elem$conv$7 = anf$1;
    read [Mutable] [Buf Int] acc$conv$9 = acc$conv$9;
    write acc$conv$9 = Latest_push# [Int]
                       acc$conv$9 elem$conv$7;
  }
  save_resumable [Int] acc$c$conv$5;
  save_resumable [Buf Int] acc$conv$9;
  read [Mutable] [Int] c$conv$5 = acc$c$conv$5;
  read [Mutable] [Buf Int] conv$9 = acc$conv$9;
  let conv$6 = Latest_read# [Int]
               conv$9;
  let conv$12 = pair# [Int] [Array Int]
                c$conv$5 conv$6;
  output repl conv$12;
>>>>>>> 1c6d00cdeacf74e593a515edefbae9ff2bbba592
}

- Flattened:
gen$date = DATE
{
<<<<<<< HEAD
  init [Latest] [(Sum Error Int)] acc$conv$16 = 3 : Int;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in history {
    push acc$conv$16(elem$gen$fact);
  } 
  
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  load_resumable [Int] acc$c$conv$11;
  for_facts (elem$gen$fact : (Sum Error Int), elem$gen$date : Date) in new {
    init [Mutable] [(Sum Error Bool)] flat$0 = Left ExceptTombstone : (Sum Error Bool);
    if (Sum_isLeft# [Error] [Int]
        elem$gen$fact) {
      let flat$4 = unsafe_Sum_left# [Error] [Int]
                   elem$gen$fact;
      write flat$0 = left# [Error] [Bool]
                     flat$4;
    } else {
      let flat$5 = unsafe_Sum_right# [Error] [Int]
                   elem$gen$fact;
      let simp$1 = gt# [Int] flat$5
                   (10 : Int);
      write flat$0 = right# [Error] [Bool]
                     simp$1;
    }
    read [Mutable] [(Sum Error Bool)] flat$0 = flat$0;
    init [Mutable] [Bool] flat$1 = False : Bool;
    if (Sum_isLeft# [Error] [Bool]
        flat$0) {
      write flat$1 = True : Bool;
    } 
     else {
      let flat$3 = unsafe_Sum_right# [Error] [Bool]
                   flat$0;
      write flat$1 = flat$3;
    }
    read [Mutable] [Bool] flat$1 = flat$1;
    if (flat$1) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
    push acc$conv$16(elem$gen$fact);
  }
  save_resumable [Int] acc$c$conv$11;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  read [Latest] [(Sum Error Int)] conv$16 = acc$conv$16;
  let conv$12 = right# [Error] [Int]
                c$conv$11;
  init [Mutable] [(Sum Error (Int, Array Int))] flat$6 = Left ExceptTombstone : (Sum Error (Int, Array Int));
  if (Sum_isLeft# [Error] [Int]
      conv$12) {
    let flat$7 = unsafe_Sum_left# [Error] [Int]
                 conv$12;
    let conv$14 = left# [Error] [(Int, Array Int)]
                  flat$7;
    write flat$6 = conv$14;
  } else {
    let flat$8 = unsafe_Sum_right# [Error] [Int]
                 conv$12;
    init [Mutable] [(Sum Error (Int, Array Int))] flat$9 = Left ExceptTombstone : (Sum Error (Int, Array Int));
    if (Sum_isLeft# [Error] [Array Int]
        conv$16) {
      let flat$10 = unsafe_Sum_left# [Error] [Array Int]
                    conv$16;
      let conv$20 = left# [Error] [(Int, Array Int)]
                    flat$10;
      write flat$9 = conv$20;
    } else {
      let flat$11 = unsafe_Sum_right# [Error] [Array Int]
                    conv$16;
      let conv$22 = pair# [Int] [Array Int]
                    flat$8 flat$11;
      let conv$23 = right# [Error] [(Int, Array Int)]
                    conv$22;
      write flat$9 = conv$23;
    }
    read [Mutable] [(Sum Error (Int, Array Int))] flat$9 = flat$9;
    write flat$6 = flat$9;
  }
  read [Mutable] [(Sum Error (Int, Array Int))] flat$6 = flat$6;
  output repl flat$6;
=======
  init [Mutable] [Int] acc$c$conv$5 = 0 : Int;
  load_resumable [Int] acc$c$conv$5;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    if (gt# [Int] elem$gen$fact
        (10 : Int)) {
      read [Mutable] [Int] acc$c$conv$5 = acc$c$conv$5;
      write acc$c$conv$5 = add# [Int]
                           acc$c$conv$5 (1 : Int);
    }
  } 
  
  save_resumable [Int] acc$c$conv$5;
  read [Mutable] [Int] c$conv$5 = acc$c$conv$5;
  let flat$1 = Buf_read# [Int]
               ([ExceptScalarVariableNotAvailable
                ,ExceptScalarVariableNotAvailable
                ,ExceptScalarVariableNotAvailable] : Buf Int);
  let conv$12 = pair# [Int] [Array Int]
                c$conv$5 flat$1;
  output repl conv$12;
>>>>>>> 1c6d00cdeacf74e593a515edefbae9ff2bbba592
}

- Avalanche type error:
Program error:
  ProgramErrorExp (ExpErrorApp (XPrim () (PrimProject (PrimProjectSumIsLeft ErrorT (ArrayT IntT)))) (XVar () (NameMod "conv" (Name "16"))) (FunT [FunT [] (SumT ErrorT (ArrayT IntT))] BoolT) (FunT [] (ArrayT (SumT ErrorT IntT))))

- Core error:
Runtime error:
  Postcomputation error:
    Bad arguments to primitive: 
      Primitive: Sum_fold# [Error] [Array Int] [(Sum Error (Int, Array Int))]
      Arguments: [closure# [(c$conv$11
                            ,5)
                           ,(conv$12,Right 5)
                           ,(conv$16
                            ,[Right 300
                             ,Right 400
                             ,Right 500])
                           ,(now$conv$1,1970-01-01)
                           ,(reify$5$conv$15
                            ,5)] \reify$6$conv$19. 
                 let conv$20 = left# [Error] [(Int, Array Int)]
                               reify$6$conv$19
                  in conv$20
                 ,closure# [(c$conv$11,5)
                           ,(conv$12,Right 5)
                           ,(conv$16
                            ,[Right 300
                             ,Right 400
                             ,Right 500])
                           ,(now$conv$1,1970-01-01)
                           ,(reify$5$conv$15
                            ,5)] \reify$7$conv$21. 
                 let conv$22 = pair# [Int] [Array Int]
                               reify$5$conv$15 reify$7$conv$21
                  in 
                 let conv$23 = right# [Error] [(Int, Array Int)]
                               conv$22
                  in conv$23
                 ,[Right 300
                  ,Right 400
                  ,Right 500]]

> > -- Something involves the abstract buffer type
> - Type:
Aggregate Possibly (Group DateTime Int)

- Core:
Program (source : Stream Int)
Precomputations:

Stream transformers:
conv$0 =
    source
Reductions:
conv$2 =
    rfold   [(Int, DateTime)]
    [Map DateTime (Buf (Int, DateTime))]
    (
    \conv$4 : Map DateTime (Buf (Int, DateTime)). 
    
    \conv$5 : (Int, DateTime).  
    let simp$2 = Latest_push# [(Int, DateTime)]
                 ([ExceptScalarVariableNotAvailable
                  ,ExceptScalarVariableNotAvailable] : Buf (Int, DateTime))
                 conv$5
     in 
    let simp$3 = snd# [Int] [DateTime]
                 conv$5
     in Map_insertOrUpdate# [DateTime] [Buf (Int, DateTime)]
        (
        \conv$7 : Buf (Int, DateTime). 
        Latest_push# [(Int, DateTime)]
        conv$7 conv$5) simp$2 simp$3
        conv$4)
    (Map [] : Map DateTime (Buf (Int, DateTime)))
    conv$0
Postcomputations with date as now$conv$1:
conv$3 =
    Map_mapValues# [DateTime] [Buf (Int, DateTime)] [Int]
    (
    \conv$8 : Buf (Int, DateTime).  
    let conv$11 = 
                  let conv$6 = Latest_read# [(Int, DateTime)]
                               conv$8
                   in Array_fold# [(Int, DateTime)] [(Int, (Int, Unit))]
                      (
                      \conv$10 : (Int, (Int, Unit)).  
                      \conv$9 : (Int, DateTime).  
                      let v$inline$0$conv$13 = fst# [Int] [DateTime]
                                               conv$9
                       in pair# [Int] [(Int, Unit)]
                          v$inline$0$conv$13 (
                          let conv$18 = snd# [Int] [(Int, Unit)]
                                        conv$10
                           in 
                          let s$conv$16 = 
                                          let s$conv$14 = fst# [Int] [Unit]
                                                          conv$18
                                           in add# [Int]
                                              v$inline$0$conv$13 s$conv$14
                           in pair# [Int] [Unit] s$conv$16
                              (() : Unit)))
                      ((ExceptScalarVariableNotAvailable, (0, ())) : (Int, (Int, Unit)))
                      conv$6
     in 
    let conv$18 = snd# [Int] [(Int, Unit)]
                  conv$11
     in 
    let s$conv$16 = 
                    let conv$15 = fst# [Int] [Unit]
                                  conv$18
                     in conv$15
     in s$conv$16) conv$2
Returning:
repl =
    conv$3


- Core type:
[(repl,Map DateTime Int)]

- Avalanche:
gen$date = DATE
{
  init [Mutable] [Map DateTime (Buf (Int, DateTime))] acc$conv$2 = Map [] : Map DateTime (Buf (Int, DateTime));
  load_resumable [Map DateTime (Buf (Int, DateTime))] acc$conv$2;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    let gen$fact = pair# [Int] [DateTime]
                   elem$gen$fact elem$gen$date;
    read [Mutable] [Map DateTime (Buf (Int, DateTime))] acc$conv$2 = acc$conv$2;
    let anf$0 = Latest_push# [(Int, DateTime)]
                ([ExceptScalarVariableNotAvailable
                 ,ExceptScalarVariableNotAvailable] : Buf (Int, DateTime))
                gen$fact;
    let anf$1 = snd# [Int] [DateTime]
                gen$fact;
    write acc$conv$2 = Map_insertOrUpdate# [DateTime] [Buf (Int, DateTime)]
                       (
                       \conv$7 : Buf (Int, DateTime). 
                       Latest_push# [(Int, DateTime)]
                       conv$7 gen$fact) anf$0 anf$1
                       acc$conv$2;
  }
  save_resumable [Map DateTime (Buf (Int, DateTime))] acc$conv$2;
  read [Mutable] [Map DateTime (Buf (Int, DateTime))] conv$2 = acc$conv$2;
  let conv$3 = Map_mapValues# [DateTime] [Buf (Int, DateTime)] [Int]
               (
               \conv$8 : Buf (Int, DateTime).  
               let conv$11 = 
                             let conv$6 = Latest_read# [(Int, DateTime)]
                                          conv$8
                              in Array_fold# [(Int, DateTime)] [(Int, (Int, Unit))]
                                 (
                                 \conv$10 : (Int, (Int, Unit)).  
                                 \conv$9 : (Int, DateTime).  
                                 let v$inline$0$conv$13 = fst# [Int] [DateTime]
                                                          conv$9
                                  in pair# [Int] [(Int, Unit)]
                                     v$inline$0$conv$13 (
                                     let conv$18 = snd# [Int] [(Int, Unit)]
                                                   conv$10
                                      in 
                                     let s$conv$16 = 
                                                     let s$conv$14 = fst# [Int] [Unit]
                                                                     conv$18
                                                      in add# [Int]
                                                         v$inline$0$conv$13
                                                         s$conv$14
                                      in pair# [Int] [Unit] s$conv$16
                                         (() : Unit)))
                                 ((ExceptScalarVariableNotAvailable, (0, ())) : (Int, (Int, Unit)))
                                 conv$6
                in 
               let conv$18 = snd# [Int] [(Int, Unit)]
                             conv$11
                in 
               let s$conv$16 = 
                               let conv$15 = fst# [Int] [Unit]
                                             conv$18
                                in conv$15
                in s$conv$16) conv$2;
  output repl conv$3;
}

- Flattened:
gen$date = DATE
{
  init [Mutable] [Map DateTime Int] flat$1 = Map [] : Map DateTime Int;
  foreach (flat$2 in 0 : Int..Map_length# [DateTime] [Buf (Int, DateTime)]
                              (Map [] : Map DateTime (Buf (Int, DateTime)))) {
    read [Mutable] [Map DateTime Int] flat$1 = flat$1;
    let flat$3 = unsafe_Map_index# [DateTime] [Buf (Int, DateTime)]
                 (Map [] : Map DateTime (Buf (Int, DateTime)))
                 flat$2;
    let flat$4 = fst# [DateTime] [Buf (Int, DateTime)]
                 flat$3;
    let flat$5 = snd# [DateTime] [Buf (Int, DateTime)]
                 flat$3;
    let flat$6 = Buf_read# [(Int, DateTime)]
                 flat$5;
    init [Mutable] [Int] flat$7$simp$3$simp$4 = 0 : Int;
    foreach (flat$9 in 0 : Int..Array_length# [(Int, DateTime)]
                                flat$6) {
      read [Mutable] [Int] flat$7$simp$7$simp$8 = flat$7$simp$3$simp$4;
      let flat$10 = unsafe_Array_index# [(Int, DateTime)]
                    flat$6 flat$9;
      let v$inline$0$conv$13 = fst# [Int] [DateTime]
                               flat$10;
      let s$conv$16 = add# [Int]
                      v$inline$0$conv$13
                      flat$7$simp$7$simp$8;
      write flat$7$simp$3$simp$4 = s$conv$16;
    }
    read [Mutable] [Int] flat$7$simp$11$simp$12 = flat$7$simp$3$simp$4;
    let flat$8 = Map_put# [DateTime] [Int]
                 flat$1 flat$4
                 flat$7$simp$11$simp$12;
    write flat$1 = flat$8;
  }
  read [Mutable] [Map DateTime Int] flat$1 = flat$1;
  output repl flat$1;
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > 