welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, core-simp is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Int] acc$c$conv$11 = 0 : Int;
  load_resumable [Int] acc$c$conv$11;
  for_facts (gen$fact$simp$18$simp$20 : Bool,
             gen$fact$simp$18$simp$21 : Error,
             gen$fact$simp$18$simp$22 : Int,
             gen$fact$simp$19 : DateTime) in new {
    init [Mutable] [Bool] flat$1$simp$2 = False : Bool;
    init [Mutable] [Bool] flat$1$simp$4 = False : Bool;
    if (gen$fact$simp$18$simp$20) {
      let simp$1 = gt# [Int]
                   gen$fact$simp$18$simp$22
                   (10 : Int);
      write flat$1$simp$2 = True : Bool;
      write flat$1$simp$4 = simp$1;
    } else {
      write flat$1$simp$2 = False : Bool;
      write flat$1$simp$4 = False : Bool;
    }
    read [Mutable] [Bool] flat$1$simp$5 = flat$1$simp$2;
    read [Mutable] [Bool] flat$1$simp$7 = flat$1$simp$4;
    init [Mutable] [Bool] flat$2 = False : Bool;
    if (flat$1$simp$5) {
      write flat$2 = flat$1$simp$7;
    } 
     else {
      write flat$2 = True : Bool;
    } 
    
    read [Mutable] [Bool] flat$2 = flat$2;
    if (flat$2) {
      read [Mutable] [Int] acc$c$conv$11 = acc$c$conv$11;
      write acc$c$conv$11 = add# [Int]
                            acc$c$conv$11 (1 : Int);
    }
  }
  save_resumable [Int] acc$c$conv$11;
  read [Mutable] [Int] c$conv$11 = acc$c$conv$11;
  init [Mutable] [Bool] flat$7$simp$8 = False : Bool;
  init [Mutable] [Error] flat$7$simp$9 = ExceptTombstone : Error;
  init [Mutable] [Int] flat$7$simp$10$simp$11 = 0 : Int;
  init [Mutable] [Array (Sum Error Int)] flat$7$simp$10$simp$12 = [] : Array (Sum Error Int);
  if (True : Bool) {
    let flat$10 = Buf_read# [(Sum Error Int)]
                  (Buf 3 [] : Buf (Sum Error Int));
    write flat$7$simp$8 = True : Bool;
    write flat$7$simp$9 = ExceptTombstone : Error;
    write flat$7$simp$10$simp$11 = c$conv$11;
    write flat$7$simp$10$simp$12 = flat$10;
  } else {
    write flat$7$simp$8 = False : Bool;
    write flat$7$simp$9 = ExceptTombstone : Error;
    write flat$7$simp$10$simp$11 = 0 : Int;
    write flat$7$simp$10$simp$12 = [] : Array (Sum Error Int);
  }
  read [Mutable] [Bool] flat$7$simp$13 = flat$7$simp$8;
  read [Mutable] [Error] flat$7$simp$14 = flat$7$simp$9;
  read [Mutable] [Int] flat$7$simp$15$simp$16 = flat$7$simp$10$simp$11;
  read [Mutable] [Array (Sum Error Int)] flat$7$simp$15$simp$17 = flat$7$simp$10$simp$12;
  output [(Sum Error (Int, Array (Sum Error Int)))] repl (flat$7$simp$13 : Bool,
                                                          flat$7$simp$14 : Error,
                                                          flat$7$simp$15$simp$16 : Int,
                                                          flat$7$simp$15$simp$17 : Array (Sum Error Int));
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > -- Something involves the abstract buffer type
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Bool] flat$1$simp$4 = True : Bool;
  init [Mutable] [Error] flat$1$simp$5 = ExceptTombstone : Error;
  init [Mutable] [Map DateTime Int] flat$1$simp$6 = Map [] : Map DateTime Int;
  foreach (flat$2 in 0 : Int..Map_length# [DateTime] [Buf ((Sum Error Int), DateTime)]
                              (Map [] : Map DateTime (Buf ((Sum Error Int), DateTime)))) {
    read [Mutable] [Bool] flat$1$simp$7 = flat$1$simp$4;
    read [Mutable] [Error] flat$1$simp$8 = flat$1$simp$5;
    read [Mutable] [Map DateTime Int] flat$1$simp$9 = flat$1$simp$6;
    let flat$3 = unsafe_Map_index# [DateTime] [Buf ((Sum Error Int), DateTime)]
                 (Map [] : Map DateTime (Buf ((Sum Error Int), DateTime)))
                 flat$2;
    let flat$4 = fst# [DateTime] [Buf ((Sum Error Int), DateTime)]
                 flat$3;
    let flat$5 = snd# [DateTime] [Buf ((Sum Error Int), DateTime)]
                 flat$3;
    init [Mutable] [Bool] flat$6$simp$10 = False : Bool;
    init [Mutable] [Error] flat$6$simp$11 = ExceptTombstone : Error;
    init [Mutable] [Map DateTime Int] flat$6$simp$12 = Map [] : Map DateTime Int;
    if (flat$1$simp$7) {
      let flat$9 = Buf_read# [((Sum Error Int), DateTime)]
                   flat$5;
      init [Mutable] [Bool] flat$10$simp$14$simp$18$simp$20 = True : Bool;
      init [Mutable] [Error] flat$10$simp$14$simp$18$simp$21 = ExceptTombstone : Error;
      init [Mutable] [Int] flat$10$simp$14$simp$18$simp$22 = 0 : Int;
      foreach (flat$18 in 0 : Int..Array_length# [((Sum Error Int), DateTime)]
                                   flat$9) {
        read [Mutable] [Bool] flat$10$simp$24$simp$28$simp$30 = flat$10$simp$14$simp$18$simp$20;
        read [Mutable] [Error] flat$10$simp$24$simp$28$simp$31 = flat$10$simp$14$simp$18$simp$21;
        read [Mutable] [Int] flat$10$simp$24$simp$28$simp$32 = flat$10$simp$14$simp$18$simp$22;
        let flat$19 = unsafe_Array_index# [((Sum Error Int), DateTime)]
                      flat$9 flat$18;
        let v$inline$0$conv$13 = fst# [(Sum Error Int)] [DateTime]
                                 flat$19;
        init [Mutable] [Bool] flat$20$simp$33 = False : Bool;
        init [Mutable] [Error] flat$20$simp$34 = ExceptTombstone : Error;
        init [Mutable] [Int] flat$20$simp$35 = 0 : Int;
        if (Sum_isRight# [Error] [Int]
            v$inline$0$conv$13) {
          let flat$22 = unsafe_Sum_right# [Error] [Int]
                        v$inline$0$conv$13;
          init [Mutable] [Bool] flat$23$simp$36 = False : Bool;
          init [Mutable] [Error] flat$23$simp$37 = ExceptTombstone : Error;
          init [Mutable] [Int] flat$23$simp$38 = 0 : Int;
          if (flat$10$simp$24$simp$28$simp$30) {
            let simp$1 = add# [Int]
                         flat$22
                         flat$10$simp$24$simp$28$simp$32;
            write flat$23$simp$36 = True : Bool;
            write flat$23$simp$37 = ExceptTombstone : Error;
            write flat$23$simp$38 = simp$1;
          } else {
            write flat$23$simp$36 = False : Bool;
            write flat$23$simp$37 = flat$10$simp$24$simp$28$simp$31;
            write flat$23$simp$38 = 0 : Int;
          }
          read [Mutable] [Bool] flat$23$simp$39 = flat$23$simp$36;
          read [Mutable] [Error] flat$23$simp$40 = flat$23$simp$37;
          read [Mutable] [Int] flat$23$simp$41 = flat$23$simp$38;
          write flat$20$simp$33 = flat$23$simp$39;
          write flat$20$simp$34 = flat$23$simp$40;
          write flat$20$simp$35 = flat$23$simp$41;
        } else {
          let flat$21 = unsafe_Sum_left# [Error] [Int]
                        v$inline$0$conv$13;
          write flat$20$simp$33 = False : Bool;
          write flat$20$simp$34 = flat$21;
          write flat$20$simp$35 = 0 : Int;
        }
        read [Mutable] [Bool] flat$20$simp$42 = flat$20$simp$33;
        read [Mutable] [Error] flat$20$simp$43 = flat$20$simp$34;
        read [Mutable] [Int] flat$20$simp$44 = flat$20$simp$35;
        write flat$10$simp$14$simp$18$simp$20 = flat$20$simp$42;
        write flat$10$simp$14$simp$18$simp$21 = flat$20$simp$43;
        write flat$10$simp$14$simp$18$simp$22 = flat$20$simp$44;
      }
      read [Mutable] [Bool] flat$10$simp$46$simp$50$simp$52 = flat$10$simp$14$simp$18$simp$20;
      read [Mutable] [Error] flat$10$simp$46$simp$50$simp$53 = flat$10$simp$14$simp$18$simp$21;
      read [Mutable] [Int] flat$10$simp$46$simp$50$simp$54 = flat$10$simp$14$simp$18$simp$22;
      init [Mutable] [Bool] flat$11$simp$55 = False : Bool;
      init [Mutable] [Error] flat$11$simp$56 = ExceptTombstone : Error;
      init [Mutable] [Map DateTime Int] flat$11$simp$57 = Map [] : Map DateTime Int;
      if (flat$10$simp$46$simp$50$simp$52) {
        let flat$14 = Map_lookup# [DateTime] [Int]
                      flat$1$simp$9 flat$4;
        if (Option_isSome# [Int]
            flat$14) {
          let flat$15 = unsafe_Option_get# [Int]
                        flat$14;
          let flat$16 = Map_put# [DateTime] [Int]
                        flat$1$simp$9 flat$4 flat$15;
          write flat$11$simp$55 = True : Bool;
          write flat$11$simp$56 = ExceptTombstone : Error;
          write flat$11$simp$57 = flat$16;
        } else {
          let flat$17 = Map_put# [DateTime] [Int]
                        flat$1$simp$9 flat$4
                        flat$10$simp$46$simp$50$simp$54;
          write flat$11$simp$55 = True : Bool;
          write flat$11$simp$56 = ExceptTombstone : Error;
          write flat$11$simp$57 = flat$17;
        }
      } else {
        write flat$11$simp$55 = False : Bool;
        write flat$11$simp$56 = flat$10$simp$46$simp$50$simp$53;
        write flat$11$simp$57 = Map [] : Map DateTime Int;
      }
      read [Mutable] [Bool] flat$11$simp$58 = flat$11$simp$55;
      read [Mutable] [Error] flat$11$simp$59 = flat$11$simp$56;
      read [Mutable] [Map DateTime Int] flat$11$simp$60 = flat$11$simp$57;
      write flat$6$simp$10 = flat$11$simp$58;
      write flat$6$simp$11 = flat$11$simp$59;
      write flat$6$simp$12 = flat$11$simp$60;
    } else {
      write flat$6$simp$10 = False : Bool;
      write flat$6$simp$11 = flat$1$simp$8;
      write flat$6$simp$12 = Map [] : Map DateTime Int;
    }
    read [Mutable] [Bool] flat$6$simp$61 = flat$6$simp$10;
    read [Mutable] [Error] flat$6$simp$62 = flat$6$simp$11;
    read [Mutable] [Map DateTime Int] flat$6$simp$63 = flat$6$simp$12;
    write flat$1$simp$4 = flat$6$simp$61;
    write flat$1$simp$5 = flat$6$simp$62;
    write flat$1$simp$6 = flat$6$simp$63;
  }
  read [Mutable] [Bool] flat$1$simp$64 = flat$1$simp$4;
  read [Mutable] [Error] flat$1$simp$65 = flat$1$simp$5;
  read [Mutable] [Map DateTime Int] flat$1$simp$66 = flat$1$simp$6;
  output [(Sum Error (Map DateTime Int))] repl (flat$1$simp$64 : Bool,
                                                flat$1$simp$65 : Error,
                                                flat$1$simp$66 : Map DateTime Int);
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > > 