welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, core-simp is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Flattened:
gen$date = DATE
{
  init acc$c$conv$13$simp$4@{Mutable Bool} = True@{Bool};
  init acc$c$conv$13$simp$5@{Mutable Error} = ExceptTombstone@{Error};
  init acc$c$conv$13$simp$6@{Mutable Int} = 0@{Int};
  init acc$conv$30@{Mutable Buf (Sum Error Int)} = Buf 3 []@{Buf (Sum Error Int)};
  load_resumable@{Bool} acc$c$conv$13$simp$4;
  load_resumable@{Error} acc$c$conv$13$simp$5;
  load_resumable@{Int} acc$c$conv$13$simp$6;
  load_resumable@{Buf (Sum Error Int)} acc$conv$30;
  for_facts (gen$fact$simp$47$simp$49@{Bool},
             gen$fact$simp$47$simp$50@{Error},
             gen$fact$simp$47$simp$51@{Int},
             gen$fact$simp$48@{DateTime}) in new {
    read@{Mutable Buf (Sum Error Int)} acc$conv$30 = acc$conv$30;
    let simp$54 = Sum_pack#@{Error Int}
                  gen$fact$simp$47$simp$49
                  gen$fact$simp$47$simp$50
                  gen$fact$simp$47$simp$51;
    let flat$0 = Buf_push#@{(Sum Error Int)}
                 acc$conv$30 simp$54;
    write acc$conv$30 = flat$0;
    init flat$1$simp$7@{Mutable Bool} = False@{Bool};
    init flat$1$simp$9@{Mutable Bool} = False@{Bool};
    if (gen$fact$simp$47$simp$49) {
      let simp$1 = gt#@{Int}
                   gen$fact$simp$47$simp$51 (10@{Int});
      write flat$1$simp$7 = True@{Bool};
      write flat$1$simp$9 = simp$1;
    } else {
      write flat$1$simp$7 = False@{Bool};
      write flat$1$simp$9 = False@{Bool};
    }
    read@{Mutable Bool} flat$1$simp$10 = flat$1$simp$7;
    read@{Mutable Bool} flat$1$simp$12 = flat$1$simp$9;
    init flat$2@{Mutable Bool} = False@{Bool};
    if (flat$1$simp$10) {
      write flat$2 = flat$1$simp$12;
    } 
     else {
      write flat$2 = True@{Bool};
    } 
    
    read@{Mutable Bool} flat$2 = flat$2;
    if (flat$2) {
      read@{Mutable Bool} acc$c$conv$13$simp$13 = acc$c$conv$13$simp$4;
      read@{Mutable Error} acc$c$conv$13$simp$14 = acc$c$conv$13$simp$5;
      read@{Mutable Int} acc$c$conv$13$simp$15 = acc$c$conv$13$simp$6;
      init flat$3$simp$16@{Mutable Bool} = False@{Bool};
      init flat$3$simp$17@{Mutable Error} = ExceptTombstone@{Error};
      init flat$3$simp$18@{Mutable Int} = 0@{Int};
      if (gen$fact$simp$47$simp$49) {
        init flat$6$simp$19@{Mutable Bool} = False@{Bool};
        init flat$6$simp$20@{Mutable Error} = ExceptTombstone@{Error};
        init flat$6$simp$21@{Mutable Int} = 0@{Int};
        if (acc$c$conv$13$simp$13) {
          let simp$3 = add#@{Int}
                       acc$c$conv$13$simp$15 (1@{Int});
          write flat$6$simp$19 = True@{Bool};
          write flat$6$simp$20 = ExceptTombstone@{Error};
          write flat$6$simp$21 = simp$3;
        } else {
          write flat$6$simp$19 = False@{Bool};
          write flat$6$simp$20 = acc$c$conv$13$simp$14;
          write flat$6$simp$21 = 0@{Int};
        }
        read@{Mutable Bool} flat$6$simp$22 = flat$6$simp$19;
        read@{Mutable Error} flat$6$simp$23 = flat$6$simp$20;
        read@{Mutable Int} flat$6$simp$24 = flat$6$simp$21;
        init flat$7$simp$25@{Mutable Bool} = False@{Bool};
        init flat$7$simp$26@{Mutable Error} = ExceptTombstone@{Error};
        init flat$7$simp$27@{Mutable Int} = 0@{Int};
        if (flat$6$simp$22) {
          write flat$7$simp$25 = True@{Bool};
          write flat$7$simp$26 = ExceptTombstone@{Error};
          write flat$7$simp$27 = flat$6$simp$24;
        } else {
          write flat$7$simp$25 = False@{Bool};
          write flat$7$simp$26 = flat$6$simp$23;
          write flat$7$simp$27 = 0@{Int};
        }
        read@{Mutable Bool} flat$7$simp$28 = flat$7$simp$25;
        read@{Mutable Error} flat$7$simp$29 = flat$7$simp$26;
        read@{Mutable Int} flat$7$simp$30 = flat$7$simp$27;
        write flat$3$simp$16 = flat$7$simp$28;
        write flat$3$simp$17 = flat$7$simp$29;
        write flat$3$simp$18 = flat$7$simp$30;
      } else {
        write flat$3$simp$16 = False@{Bool};
        write flat$3$simp$17 = gen$fact$simp$47$simp$50;
        write flat$3$simp$18 = 0@{Int};
      }
      read@{Mutable Bool} flat$3$simp$31 = flat$3$simp$16;
      read@{Mutable Error} flat$3$simp$32 = flat$3$simp$17;
      read@{Mutable Int} flat$3$simp$33 = flat$3$simp$18;
      write acc$c$conv$13$simp$4 = flat$3$simp$31;
      write acc$c$conv$13$simp$5 = flat$3$simp$32;
      write acc$c$conv$13$simp$6 = flat$3$simp$33;
    }
  }
  save_resumable@{Bool} acc$c$conv$13$simp$4;
  save_resumable@{Error} acc$c$conv$13$simp$5;
  save_resumable@{Int} acc$c$conv$13$simp$6;
  save_resumable@{Buf (Sum Error Int)} acc$conv$30;
  read@{Mutable Bool} c$conv$13$simp$34 = acc$c$conv$13$simp$4;
  read@{Mutable Error} c$conv$13$simp$35 = acc$c$conv$13$simp$5;
  read@{Mutable Int} c$conv$13$simp$36 = acc$c$conv$13$simp$6;
  read@{Mutable Buf (Sum Error Int)} conv$30 = acc$conv$30;
  init flat$16$simp$37@{Mutable Bool} = False@{Bool};
  init flat$16$simp$38@{Mutable Error} = ExceptTombstone@{Error};
  init flat$16$simp$39$simp$40@{Mutable Int} = 0@{Int};
  init flat$16$simp$39$simp$41@{Mutable Array (Sum Error Int)} = []@{Array (Sum Error Int)};
  if (c$conv$13$simp$34) {
    let flat$19 = Buf_read#@{(Sum Error Int)}
                  conv$30;
    write flat$16$simp$37 = True@{Bool};
    write flat$16$simp$38 = ExceptTombstone@{Error};
    write flat$16$simp$39$simp$40 = c$conv$13$simp$36;
    write flat$16$simp$39$simp$41 = flat$19;
  } else {
    write flat$16$simp$37 = False@{Bool};
    write flat$16$simp$38 = c$conv$13$simp$35;
    write flat$16$simp$39$simp$40 = 0@{Int};
    write flat$16$simp$39$simp$41 = []@{Array (Sum Error Int)};
  }
  read@{Mutable Bool} flat$16$simp$42 = flat$16$simp$37;
  read@{Mutable Error} flat$16$simp$43 = flat$16$simp$38;
  read@{Mutable Int} flat$16$simp$44$simp$45 = flat$16$simp$39$simp$40;
  read@{Mutable Array (Sum Error Int)} flat$16$simp$44$simp$46 = flat$16$simp$39$simp$41;
  output@{(Sum Error (Int, Array (Sum Error Int)))} repl (flat$16$simp$42@{Bool},
               flat$16$simp$43@{Error},
               flat$16$simp$44$simp$45@{Int},
               flat$16$simp$44$simp$46@{Array (Sum Error Int)});
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > -- Something involves the abstract buffer type
> - Flattened:
gen$date = DATE
{
  init acc$conv$2@{Mutable Map DateTime (Buf ((Sum Error Int), DateTime))} = Map []@{Map DateTime (Buf ((Sum Error Int), DateTime))};
  load_resumable@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2;
  for_facts (gen$fact$simp$103$simp$105@{Bool},
             gen$fact$simp$103$simp$106@{Error},
             gen$fact$simp$103$simp$107@{Int},
             gen$fact$simp$104@{DateTime}) in new {
    read@{Mutable Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2 = acc$conv$2;
    let simp$110 = Sum_pack#@{Error Int}
                   gen$fact$simp$103$simp$105
                   gen$fact$simp$103$simp$106
                   gen$fact$simp$103$simp$107;
    let simp$111 = pair#@{(Sum Error Int) DateTime} simp$110
                   gen$fact$simp$104;
    let flat$0 = Buf_push#@{((Sum Error Int), DateTime)}
                 (Buf 2 []@{Buf ((Sum Error Int), DateTime)}) simp$111;
    init flat$1@{Mutable Bool} = False@{Bool};
    init flat$2@{Mutable Array DateTime} = Map_unpack_keys#@{DateTime Buf ((Sum Error Int), DateTime)}
                  acc$conv$2;
    init flat$3@{Mutable Array (Buf ((Sum Error Int), DateTime))} = Map_unpack_values#@{DateTime Buf ((Sum Error Int), DateTime)}
                  acc$conv$2;
    read@{Mutable Array DateTime} flat$2 = flat$2;
    let flat$4 = Array_length#@{DateTime}
                 flat$2;
    foreach (flat$5 in 0@{Int}..flat$4) {
      read@{Mutable Array DateTime} flat$2 = flat$2;
      read@{Mutable Array (Buf ((Sum Error Int), DateTime))} flat$3 = flat$3;
      let simp$1 = unsafe_Array_index#@{DateTime}
                   flat$2 flat$5;
      if (eq#@{DateTime} simp$1
          gen$fact$simp$104) {
        let flat$6 = unsafe_Array_index#@{Buf ((Sum Error Int), DateTime)}
                     flat$3 flat$5;
        let flat$7 = Buf_push#@{((Sum Error Int), DateTime)} flat$6
                     simp$111;
        write flat$3 = Array_put#@{Buf ((Sum Error Int), DateTime)} flat$3
                       flat$5 flat$7;
        write flat$1 = True@{Bool};
      }
    }
    read@{Mutable Bool} flat$1 = flat$1;
    if (flat$1) {
      
    } else {
      read@{Mutable Array DateTime} flat$9 = flat$2;
      let simp$4 = Array_length#@{DateTime}
                   flat$9;
      let simp$5 = add#@{Int} simp$4 (1@{Int});
      init flat$8@{Mutable Array DateTime} = unsafe_Array_create#@{DateTime}
                    simp$5;
      foreach (flat$10 in 0@{Int}..Array_length#@{DateTime}
                             flat$9) {
        read@{Mutable Array DateTime} flat$8 = flat$8;
        let simp$7 = unsafe_Array_index#@{DateTime}
                     flat$9 flat$10;
        write flat$8 = Array_put#@{DateTime} flat$8
                       flat$10 simp$7;
      }
      read@{Mutable Array DateTime} flat$8 = flat$8;
      write flat$8 = Array_put#@{DateTime} flat$8
                     simp$4 gen$fact$simp$104;
      read@{Mutable Array DateTime} flat$8 = flat$8;
      write flat$2 = flat$8;
      read@{Mutable Array (Buf ((Sum Error Int), DateTime))} flat$12 = flat$3;
      let simp$12 = Array_length#@{Buf ((Sum Error Int), DateTime)}
                    flat$12;
      let simp$13 = add#@{Int} simp$12 (1@{Int});
      init flat$11@{Mutable Array (Buf ((Sum Error Int), DateTime))} = unsafe_Array_create#@{Buf ((Sum Error Int), DateTime)}
                     simp$13;
      foreach (flat$13 in 0@{Int}..Array_length#@{Buf ((Sum Error Int), DateTime)}
                             flat$12) {
        read@{Mutable Array (Buf ((Sum Error Int), DateTime))} flat$11 = flat$11;
        let simp$15 = unsafe_Array_index#@{Buf ((Sum Error Int), DateTime)}
                      flat$12 flat$13;
        write flat$11 = Array_put#@{Buf ((Sum Error Int), DateTime)}
                        flat$11 flat$13 simp$15;
      }
      read@{Mutable Array (Buf ((Sum Error Int), DateTime))} flat$11 = flat$11;
      write flat$11 = Array_put#@{Buf ((Sum Error Int), DateTime)}
                      flat$11 simp$12 flat$0;
      read@{Mutable Array (Buf ((Sum Error Int), DateTime))} flat$11 = flat$11;
      write flat$3 = flat$11;
    }
    read@{Mutable Array DateTime} flat$2 = flat$2;
    read@{Mutable Array (Buf ((Sum Error Int), DateTime))} flat$3 = flat$3;
    let flat$14 = Map_pack#@{DateTime Buf ((Sum Error Int), DateTime)} flat$2
                  flat$3;
    write acc$conv$2 = flat$14;
  }
  save_resumable@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2;
  read@{Mutable Map DateTime (Buf ((Sum Error Int), DateTime))} conv$2 = acc$conv$2;
  let flat$15 = Map_unpack_keys#@{DateTime Buf ((Sum Error Int), DateTime)}
                conv$2;
  let flat$16 = Map_unpack_values#@{DateTime Buf ((Sum Error Int), DateTime)}
                conv$2;
  init flat$20$simp$40@{Mutable Bool} = True@{Bool};
  init flat$20$simp$41@{Mutable Error} = ExceptTombstone@{Error};
  init flat$20$simp$42@{Mutable Map DateTime Int} = Map []@{Map DateTime Int};
  foreach (flat$21 in 0@{Int}..Array_length#@{DateTime}
                         flat$15) {
    read@{Mutable Bool} flat$20$simp$43 = flat$20$simp$40;
    read@{Mutable Error} flat$20$simp$44 = flat$20$simp$41;
    read@{Mutable Map DateTime Int} flat$20$simp$45 = flat$20$simp$42;
    let conv$26 = unsafe_Array_index#@{DateTime}
                  flat$15 flat$21;
    let conv$5 = unsafe_Array_index#@{Buf ((Sum Error Int), DateTime)}
                 flat$16 flat$21;
    init flat$23$simp$46@{Mutable Bool} = False@{Bool};
    init flat$23$simp$47@{Mutable Error} = ExceptTombstone@{Error};
    init flat$23$simp$48@{Mutable Map DateTime Int} = Map []@{Map DateTime Int};
    if (flat$20$simp$43) {
      let flat$26 = Buf_read#@{((Sum Error Int), DateTime)}
                    conv$5;
      init flat$27$simp$50$simp$54$simp$56@{Mutable Bool} = True@{Bool};
      init flat$27$simp$50$simp$54$simp$57@{Mutable Error} = ExceptTombstone@{Error};
      init flat$27$simp$50$simp$54$simp$58@{Mutable Int} = 0@{Int};
      foreach (flat$44 in 0@{Int}..Array_length#@{((Sum Error Int), DateTime)}
                             flat$26) {
        read@{Mutable Bool} flat$27$simp$60$simp$64$simp$66 = flat$27$simp$50$simp$54$simp$56;
        read@{Mutable Error} flat$27$simp$60$simp$64$simp$67 = flat$27$simp$50$simp$54$simp$57;
        read@{Mutable Int} flat$27$simp$60$simp$64$simp$68 = flat$27$simp$50$simp$54$simp$58;
        let flat$45 = unsafe_Array_index#@{((Sum Error Int), DateTime)}
                      flat$26 flat$44;
        let v$inline$0$conv$13 = fst#@{(Sum Error Int) DateTime}
                                 flat$45;
        init flat$46$simp$69@{Mutable Bool} = False@{Bool};
        init flat$46$simp$70@{Mutable Error} = ExceptTombstone@{Error};
        init flat$46$simp$71@{Mutable Int} = 0@{Int};
        if (Sum_isRight#@{Error Int}
            v$inline$0$conv$13) {
          let flat$48 = unsafe_Sum_right#@{Error Int}
                        v$inline$0$conv$13;
          init flat$49$simp$72@{Mutable Bool} = False@{Bool};
          init flat$49$simp$73@{Mutable Error} = ExceptTombstone@{Error};
          init flat$49$simp$74@{Mutable Int} = 0@{Int};
          if (flat$27$simp$60$simp$64$simp$66) {
            let simp$19 = add#@{Int} flat$48
                          flat$27$simp$60$simp$64$simp$68;
            write flat$49$simp$72 = True@{Bool};
            write flat$49$simp$73 = ExceptTombstone@{Error};
            write flat$49$simp$74 = simp$19;
          } else {
            write flat$49$simp$72 = False@{Bool};
            write flat$49$simp$73 = flat$27$simp$60$simp$64$simp$67;
            write flat$49$simp$74 = 0@{Int};
          }
          read@{Mutable Bool} flat$49$simp$75 = flat$49$simp$72;
          read@{Mutable Error} flat$49$simp$76 = flat$49$simp$73;
          read@{Mutable Int} flat$49$simp$77 = flat$49$simp$74;
          write flat$46$simp$69 = flat$49$simp$75;
          write flat$46$simp$70 = flat$49$simp$76;
          write flat$46$simp$71 = flat$49$simp$77;
        } else {
          let flat$47 = unsafe_Sum_left#@{Error, Int}
                        v$inline$0$conv$13;
          write flat$46$simp$69 = False@{Bool};
          write flat$46$simp$70 = flat$47;
          write flat$46$simp$71 = 0@{Int};
        }
        read@{Mutable Bool} flat$46$simp$78 = flat$46$simp$69;
        read@{Mutable Error} flat$46$simp$79 = flat$46$simp$70;
        read@{Mutable Int} flat$46$simp$80 = flat$46$simp$71;
        write flat$27$simp$50$simp$54$simp$56 = flat$46$simp$78;
        write flat$27$simp$50$simp$54$simp$57 = flat$46$simp$79;
        write flat$27$simp$50$simp$54$simp$58 = flat$46$simp$80;
      }
      read@{Mutable Bool} flat$27$simp$82$simp$86$simp$88 = flat$27$simp$50$simp$54$simp$56;
      read@{Mutable Error} flat$27$simp$82$simp$86$simp$89 = flat$27$simp$50$simp$54$simp$57;
      read@{Mutable Int} flat$27$simp$82$simp$86$simp$90 = flat$27$simp$50$simp$54$simp$58;
      init flat$28$simp$91@{Mutable Bool} = False@{Bool};
      init flat$28$simp$92@{Mutable Error} = ExceptTombstone@{Error};
      init flat$28$simp$93@{Mutable Map DateTime Int} = Map []@{Map DateTime Int};
      if (flat$27$simp$82$simp$86$simp$88) {
        init flat$31@{Mutable Bool} = False@{Bool};
        init flat$32@{Mutable Array DateTime} = Map_unpack_keys#@{DateTime Int}
                       flat$20$simp$45;
        init flat$33@{Mutable Array Int} = Map_unpack_values#@{DateTime Int}
                       flat$20$simp$45;
        read@{Mutable Array DateTime} flat$32 = flat$32;
        let flat$34 = Array_length#@{DateTime}
                      flat$32;
        foreach (flat$35 in 0@{Int}..flat$34) {
          read@{Mutable Array DateTime} flat$32 = flat$32;
          read@{Mutable Array Int} flat$33 = flat$33;
          let simp$23 = unsafe_Array_index#@{DateTime}
                        flat$32 flat$35;
          if (eq#@{DateTime} simp$23 conv$26) {
            let flat$36 = unsafe_Array_index#@{Int}
                          flat$33 flat$35;
            write flat$33 = Array_put#@{Int}
                            flat$33 flat$35 flat$36;
            write flat$31 = True@{Bool};
          }
        }
        read@{Mutable Bool} flat$31 = flat$31;
        if (flat$31) {
          
        } else {
          read@{Mutable Array DateTime} flat$38 = flat$32;
          let simp$26 = Array_length#@{DateTime}
                        flat$38;
          let simp$27 = add#@{Int} simp$26 (1@{Int});
          init flat$37@{Mutable Array DateTime} = unsafe_Array_create#@{DateTime}
                         simp$27;
          foreach (flat$39 in 0@{Int}..Array_length#@{DateTime}
                                 flat$38) {
            read@{Mutable Array DateTime} flat$37 = flat$37;
            let simp$29 = unsafe_Array_index#@{DateTime}
                          flat$38 flat$39;
            write flat$37 = Array_put#@{DateTime}
                            flat$37 flat$39 simp$29;
          }
          read@{Mutable Array DateTime} flat$37 = flat$37;
          write flat$37 = Array_put#@{DateTime}
                          flat$37 simp$26 conv$26;
          read@{Mutable Array DateTime} flat$37 = flat$37;
          write flat$32 = flat$37;
          read@{Mutable Array Int} flat$41 = flat$33;
          let simp$34 = Array_length#@{Int}
                        flat$41;
          let simp$35 = add#@{Int} simp$34 (1@{Int});
          init flat$40@{Mutable Array Int} = unsafe_Array_create#@{Int}
                         simp$35;
          foreach (flat$42 in 0@{Int}..Array_length#@{Int}
                                 flat$41) {
            read@{Mutable Array Int} flat$40 = flat$40;
            let simp$37 = unsafe_Array_index#@{Int}
                          flat$41 flat$42;
            write flat$40 = Array_put#@{Int}
                            flat$40 flat$42 simp$37;
          }
          read@{Mutable Array Int} flat$40 = flat$40;
          write flat$40 = Array_put#@{Int}
                          flat$40 simp$34
                          flat$27$simp$82$simp$86$simp$90;
          read@{Mutable Array Int} flat$40 = flat$40;
          write flat$33 = flat$40;
        }
        read@{Mutable Array DateTime} flat$32 = flat$32;
        read@{Mutable Array Int} flat$33 = flat$33;
        let flat$43 = Map_pack#@{DateTime Int} flat$32
                      flat$33;
        write flat$28$simp$91 = True@{Bool};
        write flat$28$simp$92 = ExceptTombstone@{Error};
        write flat$28$simp$93 = flat$43;
      } else {
        write flat$28$simp$91 = False@{Bool};
        write flat$28$simp$92 = flat$27$simp$82$simp$86$simp$89;
        write flat$28$simp$93 = Map []@{Map DateTime Int};
      }
      read@{Mutable Bool} flat$28$simp$94 = flat$28$simp$91;
      read@{Mutable Error} flat$28$simp$95 = flat$28$simp$92;
      read@{Mutable Map DateTime Int} flat$28$simp$96 = flat$28$simp$93;
      write flat$23$simp$46 = flat$28$simp$94;
      write flat$23$simp$47 = flat$28$simp$95;
      write flat$23$simp$48 = flat$28$simp$96;
    } else {
      write flat$23$simp$46 = False@{Bool};
      write flat$23$simp$47 = flat$20$simp$44;
      write flat$23$simp$48 = Map []@{Map DateTime Int};
    }
    read@{Mutable Bool} flat$23$simp$97 = flat$23$simp$46;
    read@{Mutable Error} flat$23$simp$98 = flat$23$simp$47;
    read@{Mutable Map DateTime Int} flat$23$simp$99 = flat$23$simp$48;
    write flat$20$simp$40 = flat$23$simp$97;
    write flat$20$simp$41 = flat$23$simp$98;
    write flat$20$simp$42 = flat$23$simp$99;
  }
  read@{Mutable Bool} flat$20$simp$100 = flat$20$simp$40;
  read@{Mutable Error} flat$20$simp$101 = flat$20$simp$41;
  read@{Mutable Map DateTime Int} flat$20$simp$102 = flat$20$simp$42;
  output@{(Sum Error (Map DateTime Int))} repl (flat$20$simp$100@{Bool},
               flat$20$simp$101@{Error},
               flat$20$simp$102@{Map DateTime Int});
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > > 