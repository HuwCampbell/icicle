welcome to iREPL
<<<<<<< HEAD
ok, loaded 21 functions from data/libs/prelude.icicle
=======
ok, loaded 17 functions from data/libs/prelude.icicle
>>>>>>> update cli test, remove sd_old
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, flatten is now on
ok, c is now on
ok, c evaluation now on
                   _________-----_____
        _____------           __      ----_
 ___----             ___------              \
    ----________        ----                 \
                -----__    |             _____)
                     __-                /     \
         _______-----    ___--          \    /)\
   ------_______      ---____            \__/  /
                -----__    \ --    _          /\
                       --__--__     \_____/   \_/\
                               ----|   /          |
                                   |  |___________|
                                   |  | ((_(_)| )_)
                                   |  \_((_(_)|/(_)
                                   \             (
                                    \_____________)
> > -- Oldest
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Bool] acc$conv$7$simp$0 = False : Bool;
  init [Mutable] [Int] acc$conv$7$simp$1 = 0 : Int;
  load_resumable [Bool] acc$conv$7$simp$0;
  load_resumable [Int] acc$conv$7$simp$1;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    read [Mutable] [Bool] acc$conv$7$simp$2 = acc$conv$7$simp$0;
    read [Mutable] [Int] acc$conv$7$simp$3 = acc$conv$7$simp$1;
    if (acc$conv$7$simp$2) {
      write acc$conv$7$simp$0 = True : Bool;
      write acc$conv$7$simp$1 = acc$conv$7$simp$3;
    } else {
      write acc$conv$7$simp$0 = True : Bool;
      write acc$conv$7$simp$1 = elem$gen$fact;
    }
  }
  save_resumable [Bool] acc$conv$7$simp$0;
  save_resumable [Int] acc$conv$7$simp$1;
  read [Mutable] [Bool] conv$7$simp$4 = acc$conv$7$simp$0;
  read [Mutable] [Int] conv$7$simp$5 = acc$conv$7$simp$1;
  if (conv$7$simp$4) {
    output repl conv$7$simp$5;
  } 
   else {
    output repl ExceptFold1NoValue : Int;
  } 
  
}

- C:
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef uint64_t iunit_t;
typedef uint64_t ibool_t;
typedef  int64_t iint_t;
typedef   double idouble_t;
typedef  int64_t idate_t;

typedef const char *ierror_t;

typedef struct {
    /* inputs */
    idate_t    gen_date;
    iint_t     new_count;
    idate_t   *new_date;
    iint_t    *new_fact;

    /* outputs */
    ierror_t   error;
    iint_t     repl;

    /* resumables */
    ibool_t    acc_conv_7_simp_0;
    iint_t     acc_conv_7_simp_1;
} icicle_state_t;

static const iunit_t iunit  = 0x1c1c13;
static const ibool_t ifalse = 0;
static const ibool_t itrue  = 1;

#define INLINE __attribute__((always_inline))

static idouble_t INLINE iint_extend   (iint_t    x)              { return x; }
static iint_t    INLINE iint_add      (iint_t    x, iint_t    y) { return x +  y; }
static iint_t    INLINE iint_sub      (iint_t    x, iint_t    y) { return x -  y; }
static iint_t    INLINE iint_mul      (iint_t    x, iint_t    y) { return x *  y; }
static ibool_t   INLINE iint_gt       (iint_t    x, iint_t    y) { return x >  y; }
static ibool_t   INLINE iint_ge       (iint_t    x, iint_t    y) { return x >= y; }
static ibool_t   INLINE iint_lt       (iint_t    x, iint_t    y) { return x <  y; }
static ibool_t   INLINE iint_le       (iint_t    x, iint_t    y) { return x <= y; }
static ibool_t   INLINE iint_eq       (iint_t    x, iint_t    y) { return x == y; }
static ibool_t   INLINE iint_ne       (iint_t    x, iint_t    y) { return x != y; }

static iint_t    INLINE idouble_trunc (idouble_t x)              { return (iint_t)x; }
static idouble_t INLINE idouble_add   (idouble_t x, idouble_t y) { return x + y; }
static idouble_t INLINE idouble_sub   (idouble_t x, idouble_t y) { return x - y; }
static idouble_t INLINE idouble_mul   (idouble_t x, idouble_t y) { return x * y; }
static idouble_t INLINE idouble_pow   (idouble_t x, idouble_t y) { return pow(x, y); }
static idouble_t INLINE idouble_div   (idouble_t x, idouble_t y) { return x / y; }
static idouble_t INLINE idouble_log   (idouble_t x)              { return log(x); }
static idouble_t INLINE idouble_exp   (idouble_t x)              { return exp(x); }
static ibool_t   INLINE idouble_gt    (idouble_t x, idouble_t y) { return x >  y; }
static ibool_t   INLINE idouble_ge    (idouble_t x, idouble_t y) { return x >= y; }
static ibool_t   INLINE idouble_lt    (idouble_t x, idouble_t y) { return x <  y; }
static ibool_t   INLINE idouble_le    (idouble_t x, idouble_t y) { return x <= y; }
static ibool_t   INLINE idouble_eq    (idouble_t x, idouble_t y) { return x == y; }
static ibool_t   INLINE idouble_ne    (idouble_t x, idouble_t y) { return x != y; }

static iint_t INLINE iint_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0xBAD1c3;
}

static idouble_t INLINE idouble_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0/0;
}

void compute(icicle_state_t *s)
{
    ibool_t    acc_conv_7_simp_0;
    iint_t     acc_conv_7_simp_1;
    ibool_t    acc_conv_7_simp_2;
    iint_t     acc_conv_7_simp_3;
    ibool_t    conv_7_simp_4;
    iint_t     conv_7_simp_5;

    acc_conv_7_simp_0                    = ifalse;
    acc_conv_7_simp_1                    = 0;
    acc_conv_7_simp_0                    = s->acc_conv_7_simp_0;
    acc_conv_7_simp_1                    = s->acc_conv_7_simp_1;
    
    const iint_t            new_count    = s->new_count;
    const idate_t    *const new_date     = s->new_date;
    const iint_t     *const new_fact     = s->new_fact;
    
    for (iint_t i = 0; i < new_count; i++) {
        idate_t    elem_gen_date         = new_date[i];
        iint_t     elem_gen_fact         = new_fact[i];
        acc_conv_7_simp_2                = acc_conv_7_simp_0;
        acc_conv_7_simp_3                = acc_conv_7_simp_1;
        
        if (acc_conv_7_simp_2) {
            acc_conv_7_simp_0            = itrue;
            acc_conv_7_simp_1            = acc_conv_7_simp_3;
        } else {
            acc_conv_7_simp_0            = itrue;
            acc_conv_7_simp_1            = elem_gen_fact;
        }
        
    }
    
    s->acc_conv_7_simp_0                 = acc_conv_7_simp_0;
    s->acc_conv_7_simp_1                 = acc_conv_7_simp_1;
    conv_7_simp_4                        = acc_conv_7_simp_0;
    conv_7_simp_5                        = acc_conv_7_simp_1;
    
    if (conv_7_simp_4) {
        s->repl                          = conv_7_simp_5;
    } else {
        s->repl                          = iint_err (s, "ExceptFold1NoValue");
    }
    
}

- C evaluation:
[(homer,100),(marge,0)]

- Core evaluation:
[homer, 100,marge, 0]

> > -- Filtering works
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Int] acc$c$conv$5 = 0 : Int;
  load_resumable [Int] acc$c$conv$5;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    if (gt# [Int] elem$gen$fact
        (300 : Int)) {
      read [Mutable] [Int] acc$c$conv$5 = acc$c$conv$5;
      write acc$c$conv$5 = add# [Int]
                           acc$c$conv$5 (1 : Int);
    }
  } 
  
  save_resumable [Int] acc$c$conv$5;
  read [Mutable] [Int] c$conv$5 = acc$c$conv$5;
  output repl c$conv$5;
}

- C:
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef uint64_t iunit_t;
typedef uint64_t ibool_t;
typedef  int64_t iint_t;
typedef   double idouble_t;
typedef  int64_t idate_t;

typedef const char *ierror_t;

typedef struct {
    /* inputs */
    idate_t    gen_date;
    iint_t     new_count;
    idate_t   *new_date;
    iint_t    *new_fact;

    /* outputs */
    ierror_t   error;
    iint_t     repl;

    /* resumables */
    iint_t     acc_c_conv_5;
} icicle_state_t;

static const iunit_t iunit  = 0x1c1c13;
static const ibool_t ifalse = 0;
static const ibool_t itrue  = 1;

#define INLINE __attribute__((always_inline))

static idouble_t INLINE iint_extend   (iint_t    x)              { return x; }
static iint_t    INLINE iint_add      (iint_t    x, iint_t    y) { return x +  y; }
static iint_t    INLINE iint_sub      (iint_t    x, iint_t    y) { return x -  y; }
static iint_t    INLINE iint_mul      (iint_t    x, iint_t    y) { return x *  y; }
static ibool_t   INLINE iint_gt       (iint_t    x, iint_t    y) { return x >  y; }
static ibool_t   INLINE iint_ge       (iint_t    x, iint_t    y) { return x >= y; }
static ibool_t   INLINE iint_lt       (iint_t    x, iint_t    y) { return x <  y; }
static ibool_t   INLINE iint_le       (iint_t    x, iint_t    y) { return x <= y; }
static ibool_t   INLINE iint_eq       (iint_t    x, iint_t    y) { return x == y; }
static ibool_t   INLINE iint_ne       (iint_t    x, iint_t    y) { return x != y; }

static iint_t    INLINE idouble_trunc (idouble_t x)              { return (iint_t)x; }
static idouble_t INLINE idouble_add   (idouble_t x, idouble_t y) { return x + y; }
static idouble_t INLINE idouble_sub   (idouble_t x, idouble_t y) { return x - y; }
static idouble_t INLINE idouble_mul   (idouble_t x, idouble_t y) { return x * y; }
static idouble_t INLINE idouble_pow   (idouble_t x, idouble_t y) { return pow(x, y); }
static idouble_t INLINE idouble_div   (idouble_t x, idouble_t y) { return x / y; }
static idouble_t INLINE idouble_log   (idouble_t x)              { return log(x); }
static idouble_t INLINE idouble_exp   (idouble_t x)              { return exp(x); }
static ibool_t   INLINE idouble_gt    (idouble_t x, idouble_t y) { return x >  y; }
static ibool_t   INLINE idouble_ge    (idouble_t x, idouble_t y) { return x >= y; }
static ibool_t   INLINE idouble_lt    (idouble_t x, idouble_t y) { return x <  y; }
static ibool_t   INLINE idouble_le    (idouble_t x, idouble_t y) { return x <= y; }
static ibool_t   INLINE idouble_eq    (idouble_t x, idouble_t y) { return x == y; }
static ibool_t   INLINE idouble_ne    (idouble_t x, idouble_t y) { return x != y; }

static iint_t INLINE iint_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0xBAD1c3;
}

static idouble_t INLINE idouble_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0/0;
}

void compute(icicle_state_t *s)
{
    iint_t     acc_c_conv_5;
    iint_t     c_conv_5;

    acc_c_conv_5                         = 0;
    acc_c_conv_5                         = s->acc_c_conv_5;
    
    const iint_t            new_count    = s->new_count;
    const idate_t    *const new_date     = s->new_date;
    const iint_t     *const new_fact     = s->new_fact;
    
    for (iint_t i = 0; i < new_count; i++) {
        idate_t    elem_gen_date         = new_date[i];
        iint_t     elem_gen_fact         = new_fact[i];
        
        if (iint_gt (elem_gen_fact, 300)) {
            acc_c_conv_5                 = acc_c_conv_5;
            acc_c_conv_5                 = iint_add (acc_c_conv_5, 1);
        }
        
    }
    
    s->acc_c_conv_5                      = acc_c_conv_5;
    c_conv_5                             = acc_c_conv_5;
    s->repl                              = c_conv_5;
}

- C evaluation:
[(homer,2),(marge,0)]

- Core evaluation:
[homer, 2,marge, 0]

> > -- An interesting expression
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Double] acc$a$conv$9$simp$0$simp$2 = 0.0 : Double;
  init [Mutable] [Double] acc$a$conv$9$simp$0$simp$3 = 0.0 : Double;
  init [Mutable] [Double] acc$a$conv$9$simp$1 = 0.0 : Double;
  init [Mutable] [Double] acc$a$conv$38$simp$4$simp$6 = 0.0 : Double;
  init [Mutable] [Double] acc$a$conv$38$simp$4$simp$7 = 0.0 : Double;
  init [Mutable] [Double] acc$a$conv$38$simp$5 = 0.0 : Double;
  load_resumable [Double] acc$a$conv$9$simp$0$simp$2;
  load_resumable [Double] acc$a$conv$9$simp$0$simp$3;
  load_resumable [Double] acc$a$conv$9$simp$1;
  load_resumable [Double] acc$a$conv$38$simp$4$simp$6;
  load_resumable [Double] acc$a$conv$38$simp$4$simp$7;
  load_resumable [Double] acc$a$conv$38$simp$5;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    let anf$29 = doubleOfInt#
                 elem$gen$fact;
    read [Mutable] [Double] acc$a$conv$9$simp$8$simp$10 = acc$a$conv$9$simp$0$simp$2;
    read [Mutable] [Double] acc$a$conv$9$simp$8$simp$11 = acc$a$conv$9$simp$0$simp$3;
    read [Mutable] [Double] acc$a$conv$9$simp$9 = acc$a$conv$9$simp$1;
    let anf$40 = add# [Double]
                 acc$a$conv$9$simp$8$simp$10
                 (1.0 : Double);
    let anf$42 = sub# [Double]
                 anf$29
                 acc$a$conv$9$simp$8$simp$11;
    let anf$43 = div# anf$42 anf$40;
    let anf$44 = add# [Double]
                 acc$a$conv$9$simp$8$simp$11
                 anf$43;
    let anf$46 = sub# [Double]
                 anf$29 anf$44;
    let anf$47 = mul# [Double]
                 anf$42 anf$46;
    let anf$48 = add# [Double]
                 acc$a$conv$9$simp$9 anf$47;
    write acc$a$conv$9$simp$0$simp$2 = anf$40;
    write acc$a$conv$9$simp$0$simp$3 = anf$44;
    write acc$a$conv$9$simp$1 = anf$48;
    if (lt# [Int] elem$gen$fact
        (300 : Int)) {
      read [Mutable] [Double] acc$a$conv$38$simp$12$simp$14 = acc$a$conv$38$simp$4$simp$6;
      read [Mutable] [Double] acc$a$conv$38$simp$12$simp$15 = acc$a$conv$38$simp$4$simp$7;
      read [Mutable] [Double] acc$a$conv$38$simp$13 = acc$a$conv$38$simp$5;
      let anf$70 = add# [Double]
                   acc$a$conv$38$simp$12$simp$14
                   (1.0 : Double);
      let anf$72 = sub# [Double]
                   anf$29
                   acc$a$conv$38$simp$12$simp$15;
      let anf$73 = div# anf$72 anf$70;
      let anf$74 = add# [Double]
                   acc$a$conv$38$simp$12$simp$15
                   anf$73;
      let anf$76 = sub# [Double]
                   anf$29 anf$74;
      let anf$77 = mul# [Double]
                   anf$72 anf$76;
      let anf$78 = add# [Double]
                   acc$a$conv$38$simp$13 anf$77;
      write acc$a$conv$38$simp$4$simp$6 = anf$70;
      write acc$a$conv$38$simp$4$simp$7 = anf$74;
      write acc$a$conv$38$simp$5 = anf$78;
    }
  }
  save_resumable [Double] acc$a$conv$9$simp$0$simp$2;
  save_resumable [Double] acc$a$conv$9$simp$0$simp$3;
  save_resumable [Double] acc$a$conv$9$simp$1;
  save_resumable [Double] acc$a$conv$38$simp$4$simp$6;
  save_resumable [Double] acc$a$conv$38$simp$4$simp$7;
  save_resumable [Double] acc$a$conv$38$simp$5;
  read [Mutable] [Double] a$conv$9$simp$16$simp$18 = acc$a$conv$9$simp$0$simp$2;
  read [Mutable] [Double] a$conv$9$simp$17 = acc$a$conv$9$simp$1;
  read [Mutable] [Double] a$conv$38$simp$20$simp$22 = acc$a$conv$38$simp$4$simp$6;
  read [Mutable] [Double] a$conv$38$simp$21 = acc$a$conv$38$simp$5;
  let anf$84 = sub# [Double]
               a$conv$9$simp$16$simp$18
               (1.0 : Double);
  let conv$26 = div#
                a$conv$9$simp$17 anf$84;
  let conv$28 = pow# [Double]
                conv$26 (0.5 : Double);
  let anf$89 = sub# [Double]
               a$conv$38$simp$20$simp$22
               (1.0 : Double);
  let conv$55 = div#
                a$conv$38$simp$21 anf$89;
  let conv$57 = pow# [Double]
                conv$55 (0.5 : Double);
  let conv$58 = mul# [Double]
                conv$28 conv$57;
  output repl conv$58;
}

- C:
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef uint64_t iunit_t;
typedef uint64_t ibool_t;
typedef  int64_t iint_t;
typedef   double idouble_t;
typedef  int64_t idate_t;

typedef const char *ierror_t;

typedef struct {
    /* inputs */
    idate_t    gen_date;
    iint_t     new_count;
    idate_t   *new_date;
    iint_t    *new_fact;

    /* outputs */
    ierror_t   error;
    idouble_t  repl;

    /* resumables */
    idouble_t  acc_a_conv_38_simp_5;
    idouble_t  acc_a_conv_38_simp_4_simp_6;
    idouble_t  acc_a_conv_38_simp_4_simp_7;
    idouble_t  acc_a_conv_9_simp_1;
    idouble_t  acc_a_conv_9_simp_0_simp_2;
    idouble_t  acc_a_conv_9_simp_0_simp_3;
} icicle_state_t;

static const iunit_t iunit  = 0x1c1c13;
static const ibool_t ifalse = 0;
static const ibool_t itrue  = 1;

#define INLINE __attribute__((always_inline))

static idouble_t INLINE iint_extend   (iint_t    x)              { return x; }
static iint_t    INLINE iint_add      (iint_t    x, iint_t    y) { return x +  y; }
static iint_t    INLINE iint_sub      (iint_t    x, iint_t    y) { return x -  y; }
static iint_t    INLINE iint_mul      (iint_t    x, iint_t    y) { return x *  y; }
static ibool_t   INLINE iint_gt       (iint_t    x, iint_t    y) { return x >  y; }
static ibool_t   INLINE iint_ge       (iint_t    x, iint_t    y) { return x >= y; }
static ibool_t   INLINE iint_lt       (iint_t    x, iint_t    y) { return x <  y; }
static ibool_t   INLINE iint_le       (iint_t    x, iint_t    y) { return x <= y; }
static ibool_t   INLINE iint_eq       (iint_t    x, iint_t    y) { return x == y; }
static ibool_t   INLINE iint_ne       (iint_t    x, iint_t    y) { return x != y; }

static iint_t    INLINE idouble_trunc (idouble_t x)              { return (iint_t)x; }
static idouble_t INLINE idouble_add   (idouble_t x, idouble_t y) { return x + y; }
static idouble_t INLINE idouble_sub   (idouble_t x, idouble_t y) { return x - y; }
static idouble_t INLINE idouble_mul   (idouble_t x, idouble_t y) { return x * y; }
static idouble_t INLINE idouble_pow   (idouble_t x, idouble_t y) { return pow(x, y); }
static idouble_t INLINE idouble_div   (idouble_t x, idouble_t y) { return x / y; }
static idouble_t INLINE idouble_log   (idouble_t x)              { return log(x); }
static idouble_t INLINE idouble_exp   (idouble_t x)              { return exp(x); }
static ibool_t   INLINE idouble_gt    (idouble_t x, idouble_t y) { return x >  y; }
static ibool_t   INLINE idouble_ge    (idouble_t x, idouble_t y) { return x >= y; }
static ibool_t   INLINE idouble_lt    (idouble_t x, idouble_t y) { return x <  y; }
static ibool_t   INLINE idouble_le    (idouble_t x, idouble_t y) { return x <= y; }
static ibool_t   INLINE idouble_eq    (idouble_t x, idouble_t y) { return x == y; }
static ibool_t   INLINE idouble_ne    (idouble_t x, idouble_t y) { return x != y; }

static iint_t INLINE iint_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0xBAD1c3;
}

static idouble_t INLINE idouble_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0/0;
}

void compute(icicle_state_t *s)
{
    idouble_t  a_conv_38_simp_21;
    idouble_t  a_conv_38_simp_20_simp_22;
    idouble_t  a_conv_9_simp_17;
    idouble_t  a_conv_9_simp_16_simp_18;
    idouble_t  acc_a_conv_38_simp_13;
    idouble_t  acc_a_conv_38_simp_5;
    idouble_t  acc_a_conv_38_simp_12_simp_14;
    idouble_t  acc_a_conv_38_simp_12_simp_15;
    idouble_t  acc_a_conv_38_simp_4_simp_6;
    idouble_t  acc_a_conv_38_simp_4_simp_7;
    idouble_t  acc_a_conv_9_simp_1;
    idouble_t  acc_a_conv_9_simp_9;
    idouble_t  acc_a_conv_9_simp_0_simp_2;
    idouble_t  acc_a_conv_9_simp_0_simp_3;
    idouble_t  acc_a_conv_9_simp_8_simp_10;
    idouble_t  acc_a_conv_9_simp_8_simp_11;

    acc_a_conv_9_simp_0_simp_2           = 0.0;
    acc_a_conv_9_simp_0_simp_3           = 0.0;
    acc_a_conv_9_simp_1                  = 0.0;
    acc_a_conv_38_simp_4_simp_6          = 0.0;
    acc_a_conv_38_simp_4_simp_7          = 0.0;
    acc_a_conv_38_simp_5                 = 0.0;
    acc_a_conv_9_simp_0_simp_2           = s->acc_a_conv_9_simp_0_simp_2;
    acc_a_conv_9_simp_0_simp_3           = s->acc_a_conv_9_simp_0_simp_3;
    acc_a_conv_9_simp_1                  = s->acc_a_conv_9_simp_1;
    acc_a_conv_38_simp_4_simp_6          = s->acc_a_conv_38_simp_4_simp_6;
    acc_a_conv_38_simp_4_simp_7          = s->acc_a_conv_38_simp_4_simp_7;
    acc_a_conv_38_simp_5                 = s->acc_a_conv_38_simp_5;
    
    const iint_t            new_count    = s->new_count;
    const idate_t    *const new_date     = s->new_date;
    const iint_t     *const new_fact     = s->new_fact;
    
    for (iint_t i = 0; i < new_count; i++) {
        idate_t    elem_gen_date         = new_date[i];
        iint_t     elem_gen_fact         = new_fact[i];
        idouble_t  anf_29                = iint_extend (elem_gen_fact);
        acc_a_conv_9_simp_8_simp_10      = acc_a_conv_9_simp_0_simp_2;
        acc_a_conv_9_simp_8_simp_11      = acc_a_conv_9_simp_0_simp_3;
        acc_a_conv_9_simp_9              = acc_a_conv_9_simp_1;
        idouble_t  anf_40                = idouble_add (acc_a_conv_9_simp_8_simp_10, 1.0);
        idouble_t  anf_42                = idouble_sub (anf_29, acc_a_conv_9_simp_8_simp_11);
        idouble_t  anf_43                = idouble_div (anf_42, anf_40);
        idouble_t  anf_44                = idouble_add (acc_a_conv_9_simp_8_simp_11, anf_43);
        idouble_t  anf_46                = idouble_sub (anf_29, anf_44);
        idouble_t  anf_47                = idouble_mul (anf_42, anf_46);
        idouble_t  anf_48                = idouble_add (acc_a_conv_9_simp_9, anf_47);
        acc_a_conv_9_simp_0_simp_2       = anf_40;
        acc_a_conv_9_simp_0_simp_3       = anf_44;
        acc_a_conv_9_simp_1              = anf_48;
        
        if (iint_lt (elem_gen_fact, 300)) {
            acc_a_conv_38_simp_12_simp_14 = acc_a_conv_38_simp_4_simp_6;
            acc_a_conv_38_simp_12_simp_15 = acc_a_conv_38_simp_4_simp_7;
            acc_a_conv_38_simp_13        = acc_a_conv_38_simp_5;
            idouble_t  anf_70            = idouble_add (acc_a_conv_38_simp_12_simp_14, 1.0);
            idouble_t  anf_72            = idouble_sub (anf_29, acc_a_conv_38_simp_12_simp_15);
            idouble_t  anf_73            = idouble_div (anf_72, anf_70);
            idouble_t  anf_74            = idouble_add (acc_a_conv_38_simp_12_simp_15, anf_73);
            idouble_t  anf_76            = idouble_sub (anf_29, anf_74);
            idouble_t  anf_77            = idouble_mul (anf_72, anf_76);
            idouble_t  anf_78            = idouble_add (acc_a_conv_38_simp_13, anf_77);
            acc_a_conv_38_simp_4_simp_6  = anf_70;
            acc_a_conv_38_simp_4_simp_7  = anf_74;
            acc_a_conv_38_simp_5         = anf_78;
        }
        
    }
    
    s->acc_a_conv_9_simp_0_simp_2        = acc_a_conv_9_simp_0_simp_2;
    s->acc_a_conv_9_simp_0_simp_3        = acc_a_conv_9_simp_0_simp_3;
    s->acc_a_conv_9_simp_1               = acc_a_conv_9_simp_1;
    s->acc_a_conv_38_simp_4_simp_6       = acc_a_conv_38_simp_4_simp_6;
    s->acc_a_conv_38_simp_4_simp_7       = acc_a_conv_38_simp_4_simp_7;
    s->acc_a_conv_38_simp_5              = acc_a_conv_38_simp_5;
    a_conv_9_simp_16_simp_18             = acc_a_conv_9_simp_0_simp_2;
    a_conv_9_simp_17                     = acc_a_conv_9_simp_1;
    a_conv_38_simp_20_simp_22            = acc_a_conv_38_simp_4_simp_6;
    a_conv_38_simp_21                    = acc_a_conv_38_simp_5;
    idouble_t  anf_84                    = idouble_sub (a_conv_9_simp_16_simp_18, 1.0);
    idouble_t  conv_26                   = idouble_div (a_conv_9_simp_17, anf_84);
    idouble_t  conv_28                   = idouble_pow (conv_26, 0.5);
    idouble_t  anf_89                    = idouble_sub (a_conv_38_simp_20_simp_22, 1.0);
    idouble_t  conv_55                   = idouble_div (a_conv_38_simp_21, anf_89);
    idouble_t  conv_57                   = idouble_pow (conv_55, 0.5);
    idouble_t  conv_58                   = idouble_mul (conv_28, conv_57);
    s->repl                              = conv_58;
}

- C evaluation:
[(homer,11180.33988749895)
,(marge,100.0)]

- Core evaluation:
[homer, 11180.33988749895
,marge, 100.0]

> 